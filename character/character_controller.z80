; Project Beest
; Character Controller -> Character are assumed to always be 16x16 (4 tiles)
; Developed by Caio Souza Oliveira
; 17 Aug 2019

; load character tiles
chr_load_character_tiles_and_palettes:
    ; load sprite tiles
    ; initialize hero tiles
    ld hl, hero_begin
    ld bc, hero_end - hero_begin
    ld a, $00
    ; automatic tile placement in memory (incremental)
    ld de, automatic_tile_placement
    ; load hero tukes
    call tilecrt_load_tiles

    ; load sprite palletes
    ld hl, hero_palette_begin
    ld de, hero_palette_end - hero_palette_begin
    ld bc, 0 ; target palette index (each palette has 4 colors)
    call sprt_load_sprite_palette

    ret


; Initialize character variables
; hl: character variable address
; bc: character position (c:X, b:Y)
; a: character tile (all 4 tiles *MUST* be in sequence)
; return: no return
chr_initialize_character:
    ; update character variable
    push hl
    ld [hl], c
    inc hl
    ld [hl], b
    inc hl
    ld [hl], 0
    inc hl
    ld [hl], 0
    inc hl
    ld [hl], a
    pop hl
    ld e, l
    ld d, h
    push de

    ; get sprite number
    call sptr_get_sprite_number_by_character_id
    push bc
    ld c, l
    ld b, h
    ; Intialize Hero Sprite
    ; X
    ld a, [de]
    ld h, a
    inc de
    ; Y
    ld a, [de]
    ld l, a
    inc de

    ; Skip scroll offset variables
    inc de ; offset x
    inc de ; offset y

    ; Sprite
    ld a, [de]
    ld d, a
    ; Metadata
    ld e, $00
    call sptr_initialize_sprite

    pop bc
    pop de
    ld bc, sprite_2
    ; X (+ 8)
    ld a, [de]
    add $08
    ld h, a 
    inc de
    ; Y
    ld a, [de]
    ld l, a
    inc de
        
    ; Skip scroll offset variables
    inc de ; offset x
    inc de ; offset y

    ; Sprite (+ 2), assumed always to be in sequence
    ld a, [de]
    add $02  
    ld d, a
    ; Metadata
    ld e, $00
    call sptr_initialize_sprite

    ret

; Normalize Screen Coordinates
; b: character X (top-left)
; c: character Y (top-left)
; return (bc): normalized coordinates
chr_normalize_coordinates:
    ld a, b
    sub a, $08
    ld b, a
    ld a, c
    sub a, $10
    ld c, a
    ret

; Convert real player character position into bounding box origin
; b: character X (top-left)
; c: character Y (top-left)
; return (bc): converted coordinates.
chr_calculate_bounding_box_origin:
    ld a, b
    add a, $03
    ld b, a
    ld a, c
    add a, $07
    ld c, a
    ret

; Convert map position in pixels into map tiles
; a: position in pixels
; return: position in tiles
chr_pixel_to_tile:
    srl a
    srl a
    srl a
    ret

; Move Character Down
; hl: character variable address
chr_move_character_down:
    ; save character var address
    ld a, l
    ld [ram_general_use_variable_1], a
    ld a, h
    ld [ram_general_use_variable_2], a

    ; Point HL to the character Y position in the character struct.
    ; BC holds the position (b:X; c:Y) of the player character *IN PIXELS*
    ld a, [hl]
    ld b, a
    inc hl
    ld a, [hl]
    ld c, a
    
    ; Normalize coordinates
    call chr_normalize_coordinates

    ; Calculate Bounding box
    ; From this point onwards, the value held by bc is the coordinate of the top-left corner of the bounding box.
    ; Conventions -> BBx = Px + 3
    ;                BBy = Py + 7
    call chr_calculate_bounding_box_origin

    ; save position for later calculation
    ld a, b
    ld [ram_general_use_variable_4], a
    ld a, c
    ld [ram_general_use_variable_5], a

    ; check collision
    push bc
    push hl

    ; add movement direction (Y + 9)
    ld a, c
    add $09
    ld c, a

    ; Convert bounding_box coordinate into screen tile coordinates
    ; PXL(X) -> TILE(X)
    ld a, b
    call chr_pixel_to_tile
    ld b, a
    ; PXL(Y) -> TILE(Y)
    ld a, c
    call chr_pixel_to_tile
    ld c, a

    ; Check Whether the tiles below the bounding box are crossable.
    ld d, b
    ld e, c
    push de
    call chr_check_vertical_movement
    pop de
    pop hl
    pop bc

    ; if a is 1, movement is already not allowed. Skip
    cp $00
    jr nz, .auto_move

    ; load current Y, move it down and store it back
    ld a, [hl]
    inc a
    ld [hl], a

    ; Scroll map if requied
    ld a, $00
    call map_scroll_map_vertically_if_needed
    ret

.auto_move:

    push bc
    ld c, a
    ; Reload original character position
    ld a, [ram_general_use_variable_1]
    ld l, a
    ld a, [ram_general_use_variable_2]
    ld h, a
    ld a, c
    pop bc

    cp $03 ; 03 means both tiles triggered the colission
    ret z

    cp $01 ; 01 means the first tile only triggered the collision 
   
    jr nz, .move_left
        ld a, [ram_general_use_variable_4]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $04
        ret c

        call chr_move_character_right
        ret
        
; to assist movement, the chacarcter may be moved automatically to the left
.move_left:
    cp $04
        jr z, .three_tile_case_offset_compensation
        ld a, [ram_general_use_variable_4]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $03
        ret nc
        jr .move_left_confirmed

.three_tile_case_offset_compensation:
    ld a, [ram_general_use_variable_4]
    and $07
    cp $07
    ret nz

.move_left_confirmed:
    call chr_move_character_left
    ret 

; Move Character Up
; hl: character variable address
chr_move_character_up:
    ; save character var address
    ld a, l
    ld [ram_general_use_variable_1], a
    ld a, h
    ld [ram_general_use_variable_2], a

    ; Point HL to the character Y position in the character struct.
    ; BC holds the position (b:X; c:Y) of the player character *IN PIXELS*
    ld a, [hl]
    ld b, a
    inc hl
    ld a, [hl]
    ld c, a
    
    ; Normalize coordinates
    call chr_normalize_coordinates

    ; Calculate Bounding box
    ; From this point onwards, the value held by bc is the coordinate of the top-left corner of the bounding box.
    ; Conventions -> BBx = Px + 3
    ;                BBy = Py + 7
    call chr_calculate_bounding_box_origin

    ; save position for later calculation
    ld a, b
    ld [ram_general_use_variable_4], a
    ld a, c
    ld [ram_general_use_variable_5], a

    ; check collision
    push bc
    push hl

    ; add movement direction (Y - 1)
    ld a, c
    sub $01
    ld c, a

    ; Convert bounding_box coordinate into screen tile coordinates
    ; PXL(X) -> TILE(X)
    ld a, b
    call chr_pixel_to_tile
    ld b, a
    ; PXL(Y) -> TILE(Y)
    ld a, c
    call chr_pixel_to_tile
    ld c, a

    ; Check Whether the tiles above the bounding box are crossable.
    ld d, b
    ld e, c
    push de
    call chr_check_vertical_movement
    pop de
    pop hl
    pop bc

    ; if a is 1, movement is already not allowed. Skip
    cp $00
    jr nz, .auto_move

    ; load current Y, move it down and store it back
    ld a, [hl]
    dec a
    ld [hl], a

    ; Scroll map if requied
    ld a, $01
    call map_scroll_map_vertically_if_needed
    ret

.auto_move:

    push bc
    ld c, a
    ; Reload original character position
    ld a, [ram_general_use_variable_1]
    ld l, a
    ld a, [ram_general_use_variable_2]
    ld h, a
    ld a, c
    pop bc

    cp $03 ; 03 means both tiles triggered the colission
    ret z

    cp $01 ; 01 means the first tile only triggered the collision 
   
    jr nz, .move_left
        ld a, [ram_general_use_variable_4]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $04
        ret c

        call chr_move_character_right
        ret
        
; to assist movement, the chacarcter may be moved automatically to the left
.move_left:
    cp $04
        jr z, .three_tile_case_offset_compensation
        ld a, [ram_general_use_variable_4]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $03
        ret nc
        jr .move_left_confirmed

.three_tile_case_offset_compensation:
    ld a, [ram_general_use_variable_4]
    and $07
    cp $07
    ret nz

.move_left_confirmed:
    call chr_move_character_left
    ret

; Move Character Left
; hl: character variable address
chr_move_character_left:
    ; save character var address
    ld a, l
    ld [ram_general_use_variable_1], a
    ld a, h
    ld [ram_general_use_variable_2], a

    ; Point HL to the character Y position in the character struct.
    ; BC holds the position (b:X; c:Y) of the player character *IN PIXELS*
    ld a, [hl]
    ld b, a
    inc hl
    ld a, [hl]
    ld c, a
    
    ; Normalize coordinates
    call chr_normalize_coordinates

    ; Calculate Bounding box
    ; From this point onwards, the value held by bc is the coordinate of the top-left corner of the bounding box.
    ; Conventions -> BBx = Px + 3
    ;                BBy = Py + 7
    call chr_calculate_bounding_box_origin

    ; save position for later calculation
    ld a, b
    ld [ram_general_use_variable_4], a
    ld a, c
    ld [ram_general_use_variable_5], a

    ; check collision
    push bc
    push hl

    ; add movement direction (Y - 1)
    ld a, b
    sub $01
    ld b, a

    ; Convert bounding_box coordinate into screen tile coordinates
    ; PXL(X) -> TILE(X)
    ld a, b
    call chr_pixel_to_tile
    ld b, a
    ; PXL(Y) -> TILE(Y)
    ld a, c
    call chr_pixel_to_tile
    ld c, a

    ; Check Whether the tiles below the bounding box are crossable.
    ld d, b
    ld e, c
    push de
    call chr_check_horizontal_movement
    pop de
    pop hl
    pop bc

    ; if a is 1, movement is already not allowed. Skip
    cp $00
    jr nz, .auto_move

        ; load current X, move it down and store it back
        dec hl
        ld a, [hl]
        dec a
        ld [hl], a

        ; Scroll map if requied
        ld a, $01
        call map_scroll_map_horizontally_if_needed
        ret

.auto_move
    
    push bc
    ld c, a
    ; Reload original character position
    ld a, [ram_general_use_variable_1]
    ld l, a
    ld a, [ram_general_use_variable_2]
    ld h, a
    ld a, c
    pop bc

    cp $03 ; 03 means both tiles triggered the colission
    ret z

    cp $01 ; 01 means the first tile only triggered the collision 
   
    jr nz, .move_up
        ld a, [ram_general_use_variable_5]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $04
        ret c

        call chr_move_character_down
        ret
        
; to assist movement, the chacarcter may be moved automatically up
.move_up:
        ld a, [ram_general_use_variable_5]
        and $07
        ; if the bounding box is at least 3 pixels touching the target collision, it wil trigger auto movemnt
        sub $04
        ret nc
        jr .move_up_confirmed

.move_up_confirmed:
    call chr_move_character_up
    ret

; Move Character Right
; hl: character variable address
chr_move_character_right:
    ; load current X, move it down and store it back
    ld a, [hl]
    inc a
    ld [hl], a

    ; Scroll map if required
    ld a, $00
    call map_scroll_map_horizontally_if_needed
    
    ret

; Extract ID of colliding object
; bc: colliding tile
; modified: a, hl
chr_get_collision_id:
    push hl
    ld a, [bc]
    ld hl, collision_target
    ; clear the MSBit and provide the 7 bits map ID
    and a, $7F
    ld [hl], a
    pop hl
    ret

; Render sprite(s) on screen, based on their index
; hl: target sprite index
chr_render_character:
    ld a, h
    ld d, a
    ld a, l
    ld e, a
    ; get character's sprites (will be stored in hl/bc)
    call sptr_get_sprite_number_by_character_id

    ; target sprite left and right (16x8 times 2) X coordinate
    ; hl holds address of the first sprite of the target character
    ld a, [de]
    push bc
    ld c, a
    ld a, [character_0_offset_x]
    add a, c
    pop bc
    inc de
    call sptr_set_sprite_x
    ld a, [de]
    push bc
    ld c, a
    ld a, [character_0_offset_y]
    add a, c
    pop bc
    dec de
    dec hl
    call sptr_set_sprite_y
    
    ; load address of second sprite from bc to hl
    ld a, [de]
    add a, $08
    push bc
    ld c, a
    ld a, [character_0_offset_x]
    add a, c
    pop bc
    ld l, c
    ld h, b
    call sptr_set_sprite_x
    inc de
    ld a, [de]
    push bc
    ld c, a
    ld a, [character_0_offset_y]
    add a, c
    pop bc
    dec hl
    call sptr_set_sprite_y
    ret

; Increment next line to the current value of DE
; de: current base address
chr_inc_next_line:
    push hl
    ld a, map_screen_width
    add a, e
    ld e, a
    ld a, d
    adc $00
    ld d, a
    pop hl
    ret

; clear collision targets
chr_clear_collision:
    ld a, $00
    ld [collision_target], a
    ld [edget_collision_target_x], a
    ld [edget_collision_target_y], a
    ret

; Character control loop iteration
; Reads input and handles movement and interactions
chr_player_controlled_character_loop:
    ; This algorithm clears the "collision target" every time a directional key is detected.
    ; Thats because the movement may or may not lead to a collision (the player can face away from a target object, or face another object).
    call joypad_is_dpad_pressed
    cp a, $01
    jr nz, .continue_movement_processing
        ; clear colision targets
        ld a, $00
        ld [collision_target], a
        ld [edget_collision_target_x], a
        ld [edget_collision_target_y], a

.continue_movement_processing:
    ; read key for directiona movement
    ld l, key_down
    call is_key_down_or_held
    jr z, .check_key_up
        ; Move Character Down
        ld hl, character_0
        call chr_move_character_down
        jr .check_key_left

.check_key_up:
    ld l, key_up
    call is_key_down_or_held
    jr z, .check_key_left
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_up
    
.check_key_left:
    ld l, key_left
    call is_key_down_or_held
    jr z, .check_key_right
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_left
        jr .end_character_movement

.check_key_right:
    ld l, key_right
    call is_key_down_or_held
    jr z, .end_character_movement
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_right

.end_character_movement:
    ; render sprite on its new position
    ld hl, character_0
    call chr_render_character
    
    ret

; Check Vertical Edges
; de: b[x], c[y] character position (in pixels)
; return a: 1 allowed, 0 not allowed
chr_check_vertical_edges:
    ld a, c
    cp $0F
    jr z, .not_allowed
    cp $A0
    jr z, .not_allowed
        ld a, $01
        ret
.not_allowed:
    ld a, $00
    ret

; Check Horizontal Edges
; de: b[x], c[y] character position (in pixels)
; return a: 1 allowed, 0 not allowed
chr_check_horizontal_edges:
    ld a, b
    cp $7
    jr z, .not_allowed
    cp $A8
    jr z, .not_allowed
        ld a, $01
        ret
.not_allowed:
    ld a, $00
    ret

; checks whether movement is alowed (vertical direction)
; de: d[x], e[y] character position (in tiles)
; return a: 1/2/3 allowed (1 tile to the right caused collision, 2, tile to the left caused collision, 
; 3 both caused the collision, 4 teh third tile below the player triggered the collision), 0 allowed
chr_check_vertical_movement:
    ld a, map_screen_width
    ld l, a
    ld h, $00

    push de
    ld d, $00
    call mul_DE_HL_BCDEu
    ld c, e
    ld b, d
    pop de
    ld a, d
    add a, c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    ; calculate address in logic map
    ld de, map_logic
    ld a, c
    add e
    ld c, a
    ld a, b
    adc d
    ld b, a

    ; Check MSBit of the target map entry
    push bc
    ; load d with 00 (no collisiton target)
    ; work your way down to check bits 0 and 1 representing collisions in tile left/right respectivelly.
    ld d, $00
    ld a, [bc]
    and a, $80
    jr z, .check_second_tile
        ; the target tile is not crossable
        ld a, d
        or $01
        ld d, a
        call chr_get_collision_id

.check_second_tile:
    ; check tile to the right
    inc bc
    ; check the case where the bounding box spans 3 pixels!!!!!!
    ld a, [bc]
    and a, $80
    jr z, .check_third_tile
        ; the target tile is not crossable
        ld a, d
        or $02
        ld d, a
        call chr_get_collision_id
        pop bc

        ; prepare return
        ld a, d
        ret

.check_third_tile:
    ld a, [ram_general_use_variable_4]
    and $07
    cp $07
    jr nz, .finalize
        inc bc
        ld a, [bc]
        and a, $80
        jr z, .finalize
            ; the target tile is not crossable
            ld a, d
            or $04
            ld d, a
            call chr_get_collision_id
            pop bc

            ; prepare return
            ld a, d
            ret

.finalize:
        pop bc
        ld a, d
        ret

; checks whether movement is alowed (horizontal direction)
; de: d[x], e[y] character position (in tiles)
; return a: 1/2/3 allowed (1 tile to the right caused collision, 2, tile to the left caused collision, 3 both caused the collision), 0 allowed
chr_check_horizontal_movement:
    ld a, map_screen_width
    ld l, a
    ld h, $00

    push de
    ld d, $00
    call mul_DE_HL_BCDEu
    ld c, e
    ld b, d
    pop de
    ld a, d
    add a, c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    ; calculate address in logic map
    ld de, map_logic
    ld a, c
    add e
    ld c, a
    ld a, b
    adc d
    ld b, a

    ; Check MSBit of the target map entry
    push bc
    ; load d with 00 (no collisiton target)
    ; work your way down to check bits 0 and 1 representing collisions in tile left/right respectivelly.
    ld d, $00
    ld a, [bc]
    and a, $80
    jr z, .check_second_tile
        ; the target tile is not crossable
        ld a, d
        or $01
        ld d, a
        call chr_get_collision_id

.check_second_tile:
    ; check tile to the below (subtract screen width from the current logic LUT address)
    ld a, map_screen_width
    add a, c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    ; check the case where the bounding box spans 3 pixels!!!!!!
    ld a, [bc]
    and a, $80
    jr z, .finalize
        ; the target tile is not crossable
        ld a, d
        or $02
        ld d, a
        call chr_get_collision_id
        pop bc

        ; prepare return
        ld a, d
        ret

.finalize:
        pop bc
        ld a, d
        ret
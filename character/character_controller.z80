; Project Beest
; Character Controller -> Character are assumed to always be 16x16 (4 tiles)
; Developed by Caio Souza Oliveira
; 17 Aug 2019

; load character tiles
chr_load_character_tiles_and_palettes:
    ; load sprite tiles
    ; initialize hero tiles
    ld hl, hero_begin
    ld bc, hero_end - hero_begin
    ld a, $00
    ; automatic tile placement in memory (incremental)
    ld de, automatic_tile_placement
    ; load hero tukes
    call tilecrt_load_tiles

    ; load sprite palletes
    ld hl, hero_palette_begin
    ld de, hero_palette_end - hero_palette_begin
    ld bc, 0 ; target palette index (each palette has 4 colors)
    call sprt_load_sprite_palette

    ret


; Initialize character variables
; hl: character variable address
; bc: character position (c:X, b:Y)
; a: character tile (all 4 tiles *MUST* be in sequence)
; return: no return
chr_initialize_character:
    ; update character variable
    push hl
    ld [hl], c
    inc hl
    ld [hl], b
    inc hl
    ld [hl], a
    pop hl
    ld e, l
    ld d, h
    push de

    ; get sprite number
    call sptr_get_sprite_number_by_character_id
    push bc
    ld c, l
    ld b, h
    ; Intialize Hero Sprite
    ; X
    ld a, [de]
    ld h, a
    inc de
    ; Y
    ld a, [de]
    ld l, a
    inc de
    ; Sprite
    ld a, [de]
    ld d, a
    ; Metadata
    ld e, $00
    call sptr_initialize_sprite

    pop bc
    pop de
    ld bc, sprite_2
    ; X (+ 8)
    ld a, [de]
    add $08
    ld h, a 
    inc de
    ; Y
    ld a, [de]
    ld l, a
    inc de
    ; Sprite (+ 2), assumed always to be in sequence
    ld a, [de]
    add $02  
    ld d, a
    ; Metadata
    ld e, $00
    call sptr_initialize_sprite

    ret

; Move Character Down
; hl: character variable address
chr_move_character_down:
    push hl
    push hl
    
    ; Convert pixel position to map position
    ; Load X position
    ld b, [hl]
    inc hl
    ; Load Y position
    ld c, [hl]

    ; compesate for sprite size (16 pixels + movement direction)
    ld a, c
    add a, 16
    ld c, a

    ; Check for edge collision
    call chr_check_vertical_edges
    cp $00
    jr z, .edge_collision_detected

    ; continue checking
    call chr_position_to_pixel
    push bc
    ; Check whether movement is allowed
    call chr_check_movement
    ; After the function call, bc holds the relative tile address (in the map_logic)
    ; copy it yo de to save calculation time.
    ld e, c
    ld d, b
    pop bc
    pop hl
    cp a, $00
    jr z, .movement_allowed_might_be_allowed
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.movement_allowed_might_be_allowed:
    ; check second sprite (increment the address in de by 1, to see whether the next tile in the map_logic is allowed)
    inc de
    ; Check whether movement is allowed
    ld a, [de]
    and a, $80
    cp a, $00
    jr z, .check_wheter_not_absoltue
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.check_wheter_not_absoltue:
    ld a, b
    and a, $07
    jr z, .movement_allowed
        ; check whether the next tile (to the right) does not generate a colision
        inc de
        ld a, [de]
        and a, $80
        cp a, $00
        jr z, .movement_allowed
            ; load colliding ID
            call chr_get_collision_id

            ; clear stack before returning
            pop hl
            ret

.edge_collision_detected:
    ; the user has collided with an edge
    call chr_position_to_pixel
    ld a, d
    inc a
    ld [edget_collision_target_x], a
    ld a, e
    inc a
    ld [edget_collision_target_y], a
    pop hl
    pop hl
    ret

.movement_allowed:
    ; if allowed, generate address of character Y
    inc hl
    ; load current Y, move it down and store it back
    ld a, [hl]
    inc a
    ld [hl], a
    pop hl
    ret

; Move Character Down
; hl: character variable address
chr_move_character_up:
    push hl
    push hl
    
    ; Convert pixel position to map position
    ; Load X position
    ld b, [hl]
    inc hl
    ; Load Y position
    ld c, [hl]
    
    ; compesate for sprite size (16 pixels + movement direction)
    ld a, c
    sub a, 1
    ld c, a

    ; Check for edge collision
    call chr_check_vertical_edges
    cp $00
    jr z, .edge_collision_detected

    ; continue checking
    call chr_position_to_pixel
    push bc
    ; Check whether movement is allowed
    call chr_check_movement
    ; After the function call, bc holds the relative tile address (in the map_logic)
    ; copy it to de to save calculation time.
    ld e, c
    ld d, b
    pop bc
    pop hl
    cp a, $00
    jr z, .movement_allowed_might_be_allowed
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.movement_allowed_might_be_allowed:
    ; check second sprite (increment the address in de by 1, to see whether the next tile in the map_logic is allowed)
    inc de
    ; Check whether movement is allowed
    ld a, [de]
    and a, $80
    cp a, $00
    jr z, .check_wheter_not_absoltue
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.check_wheter_not_absoltue:
    ld a, b
    and a, $07
    jr z, .movement_allowed
        ; check whether the next tile (to the right) does not generate a colision
        inc de
        ld a, [de]
        and a, $80
        cp a, $00
        jr z, .movement_allowed
            ; load colliding ID
            call chr_get_collision_id

            ; clear stack before returning
            pop hl
            ret

.edge_collision_detected:
    ; the user has collided with an edge
    call chr_position_to_pixel
    ld a, d
    inc a
    ld [edget_collision_target_x], a
    ld a, e
    inc a
    ld [edget_collision_target_y], a
    pop hl
    pop hl
    ret

.movement_allowed:
    ; if allowed, generate address of character Y
    inc hl
    ; load current Y, move it down and store it back
    ld a, [hl]
    dec a
    ld [hl], a
    pop hl
    ret

; Move Character Left
; hl: character variable address
chr_move_character_left:
    push hl
    push hl
    
    ; Convert pixel position to map position
    ; Load X position
    ld b, [hl]
    inc hl
    ; Load Y position
    ld c, [hl]

    ; compesate for sprite size (16 pixels + movement direction)
    ld a, b
    sub a, 1
    ld b, a

    ; Check for edge collision
    call chr_check_horizontal_edges
    cp $00
    jr z, .edge_collision_detected

    ; continue detection
    call chr_position_to_pixel
    push bc
    ; Check whether movement is allowed
    call chr_check_movement
    ; After the function call, bc holds the relative tile address (in the map_logic)
    ; copy it to de to save calculation time.
    ld e, c
    ld d, b
    pop bc
    pop hl
    cp a, $00
    jr z, .movement_allowed_might_be_allowed
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.movement_allowed_might_be_allowed:
    ; check second sprite 
    ; add map widh to de (for further calculation)
    ; de will be updated
    call chr_inc_next_line

    ; Check whether movement is allowed
    ld a, [de]
    and a, $80
    cp a, $00
    jr z, .check_wheter_not_absoltue
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.check_wheter_not_absoltue:
    ld a, c
    and a, $07
    jr z, .movement_allowed
        ; check second sprite 
        ; add map widh to de (for further calculation)
        ; de will be updated
        call chr_inc_next_line
        ld a, [de]
        and a, $80
        cp a, $00
        jr z, .movement_allowed
            ; load colliding ID
            call chr_get_collision_id

            ; clear stack before returning
            pop hl
            ret

.edge_collision_detected:
    ; the player collided with an edge
    call chr_position_to_pixel
    ld a, d
    inc a
    ld [edget_collision_target_x], a
    ld a, e
    inc a
    ld [edget_collision_target_y], a
    pop hl
    pop hl
    ret 

.movement_allowed:
    ; load current X, move it down and store it back
    ld a, [hl]
    dec a
    ld [hl], a
    pop hl
    ret

; Move Character Right
; hl: character variable address
chr_move_character_right:
    push hl
    push hl
    
    ; Convert pixel position to map position
    ; Load X position
    ld b, [hl]
    inc hl
    ; Load Y position
    ld c, [hl]

    ; compesate for sprite size (16 pixels + movement direction)
    ld a, b
    add a, 16
    ld b, a
    
    ; Check for edge collision
    call chr_check_horizontal_edges
    cp $00
    jr z, .edge_collision_detected

    ; continue detection
    call chr_position_to_pixel
    push bc
    ; save DE
    ; Check whether movement is allowed
    call chr_check_movement
    ; After the function call, bc holds the relative tile address (in the map_logic)
    ; copy it to de to save calculation time.
    ld e, c
    ld d, b
    pop bc
    pop hl
    cp a, $00
    jr z, .movement_allowed_might_be_allowed
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.movement_allowed_might_be_allowed:
    ; check second sprite 
    ; add map widh to de (for further calculation)
    ; de will be updated
    call chr_inc_next_line

    ; Check whether movement is allowed
    ld a, [de]
    and a, $80
    cp a, $00
    jr z, .check_wheter_not_absoltue
        ; load colliding ID
        call chr_get_collision_id

        ; clear stack before returning
        pop hl
        ret

.check_wheter_not_absoltue:
    ld a, c
    and a, $07
    jr z, .movement_allowed
        ; check second sprite 
        ; add map widh to de (for further calculation)
        ; de will be updated
        call chr_inc_next_line

        ; Check whether movement is allowed
        ld a, [de]
        and a, $80
        cp a, $00
        jr z, .movement_allowed
            ; load colliding ID
            call chr_get_collision_id
            
            ; clear stack before returning
            pop hl
            ret

.edge_collision_detected:
    ; the user has collided with an edge
    call chr_position_to_pixel
    ld a, d
    inc a
    ld [edget_collision_target_x], a
    ld a, e
    inc a
    ld [edget_collision_target_y], a
    pop hl
    pop hl
    ret

.movement_allowed:
    ; load current X, move it down and store it back
    ld a, [hl]
    inc a
    ld [hl], a
    pop hl
    ret

; Extract ID of colliding object
; de: colliding tile
; modified: a, hl
chr_get_collision_id:
    ld a, [de]
    ld hl, collision_target
    ; clear the MSBit and provide the 7 bits map ID
    and a, $7F
    ld [hl], a
    ret

; Render sprite(s) on screen, based on their index
; hl: target sprite index
chr_render_character:
    ld a, h
    ld d, a
    ld a, l
    ld e, a
    ; get character's sprites (will be stored in hl/bc)
    call sptr_get_sprite_number_by_character_id

    ; target sprite left and right (16x8 times 2) X coordinate
    ; hl holds address of the first sprite of the target character
    ld a, [de]
    inc de
    call sptr_set_sprite_x
    ld a, [de]
    dec de
    dec hl
    call sptr_set_sprite_y
    
    ; load address of second sprite from bc to hl
    ld a, [de]
    add a, $08
    ld l, c
    ld h, b
    call sptr_set_sprite_x
    inc de
    ld a, [de]
    dec hl
    call sptr_set_sprite_y
    ret

; Increment next line to the current value of DE
; de: current base address
chr_inc_next_line:
    push hl
    ld hl, map_current_width
    ld a, [hl]
    add a, e
    ld e, a
    ld a, d
    adc $00
    ld d, a
    pop hl
    ret

chr_clear_collision:
    ld a, $00
    ld [collision_target], a
    ld [edget_collision_target_x], a
    ld [edget_collision_target_y], a
    ret

; Character control loop iteration
; Reads input and handles movement and interactions
chr_player_controlled_character_loop:
    ; This algorithm clears the "collision target" every time a directional key is detected.
    ; Thats because the movement may or may not lead to a collision (the player can face away from a target object, or face another object).
    call joypad_is_dpad_pressed
    cp a, $01
    jr nz, .continue_movement_processing
        ; clear colision targets
        ld a, $00
        ld [collision_target], a
        ld [edget_collision_target_x], a
        ld [edget_collision_target_y], a

.continue_movement_processing:
    ; read key for directiona movement
    ld l, key_down
    call is_key_down
    jr z, .check_key_up
        ; Move Character Down
        ld hl, character_0
        call chr_move_character_down
        jr .check_key_left

.check_key_up:
    ld l, key_up
    call is_key_down
    jr z, .check_key_left
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_up
    
.check_key_left:
    ld l, key_left
    call is_key_down
    jr z, .check_key_right
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_left
        jr .end_character_movement

.check_key_right:
    ld l, key_right
    call is_key_down
    jr z, .end_character_movement
        ; Move Character Up
        ld hl, character_0
        call chr_move_character_right

.end_character_movement:
    ; render sprite on its new position
    ld hl, character_0
    call chr_render_character
    
    ret

; Detect Character position on Map (convert pixel into position)
; bc: character position in pixels (b: x, c: y)
; return d: X position; e: Y position;
chr_position_to_pixel:
    ld a, b
    sub a, $08
    srl a
    srl a
    srl a
    ld d, a

    ld a, c
    ; compensate for extra 16 pixels
    sub a, $10
    srl a
    srl a
    srl a
    ld e, a
    ret

; Check Vertical Edges
; de: b[x], c[y] character position (in pixels)
; return a: 1 allowed, 0 not allowed
chr_check_vertical_edges:
    ld a, c
    cp $0F
    jr z, .not_allowed
    cp $A0
    jr z, .not_allowed
        ld a, $01
        ret
.not_allowed:
    ld a, $00
    ret

; Check Horizontal Edges
; de: b[x], c[y] character position (in pixels)
; return a: 1 allowed, 0 not allowed
chr_check_horizontal_edges:
    ld a, b
    cp $7
    jr z, .not_allowed
    cp $A8
    jr z, .not_allowed
        ld a, $01
        ret
.not_allowed:
    ld a, $00
    ret

; checks whether movement is alowed
; de: d[x], e[y] character position (in tiles)
; return a: 1 allowed, 0 not allowed
chr_check_movement:
    ld hl, map_current_width
    ld a, [hl]
    ld l, a
    ld h, $00

    push de
    ld d, $00
    call mul_DE_HL_BCDEu
    ld c, e
    ld b, d
    pop de
    ld a, d
    add a, c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    ; calculate address in logic map
    ld de, map_logic
    ld a, c
    add e
    ld c, a
    ld a, b
    adc d
    ld b, a

    ; Check MSBit of the target map entry
    push bc
    ld a, [bc]
    and a, $80
    jr z, .may_pass
        ; the target tile is not crossable
        ld a, $01
        pop bc
        ret
.may_pass:
    ld a, $00
    pop bc
    ret
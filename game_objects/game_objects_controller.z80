; Project Beest
; Game Objects Controller
; Developed by Caio Souza Oliveira
; 01 Oct 2019

; Initialize Game Object
; a: Target game object index (0-15)
; de: game object position (d: X, e: Y)
; c: target game object sprite
goc_initialize_game_object:
    
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Note: In global_variables.z80 will holds the two halfs of the sprites in sequence.
    ; That's why hl is always incremented between each value loaded to the game object.
    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X
    ld a, d
    ld [hl], a
    inc hl

    ; Tile
    ld a, c
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X (+0x8)
    ld a, d
    add a, $08
    ld [hl], a
    inc hl

    ; Tile 2
    ; The four parts of game object (4 tiles) must be loaded in sequence in memory.
    ld a, c
    add a, $02
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ret

; Returns base address for target game object
; a: target game objecy
; hl: initial address of the game object register
goc_get_gameobject_address:
    cp a, $00
    ld hl, gobj_0_y
    ret z
    cp a, $01
    ld hl, gobj_1_y
    ret z
    cp a, $02
    ld hl, gobj_2_y
    ret z
    cp a, $03
    ld hl, gobj_3_y
    ret z
    cp a, $04
    ld hl, gobj_4_y
    ret z
    cp a, $05
    ld hl, gobj_5_y
    ret z
    ld hl, gobj_6_y
    ret


; scroll all game objects by a given amount on X and Y based on camera movement
; e: amount in X
; d: amoint in Y
goc_scroll_game_objects:

    ld a, [gobj_total_game_objects]
    ld c, a
    ld b, $00

.update_game_object:
    ld a, b
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Adjust Positions
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a

    inc b
    ld a, b
    cp c
    ret z
    jr .update_game_object


; Detects collisiton between caracter 0 and character 
; b: X position
; c: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects:

    ld a, [gobj_total_game_objects]
    ld e, a
    ld d, $00

.check_game_object:
    push de
    ld a, [map_current_y_offset]
    ld e, a
    ld a, [hl]
    sub e
    ld a, e

    inc hl
    ld a, [map_current_x_offset]
    ld d, a
    ld a, [hl]
    sub d
    ld d, a

    push hl
    ; Width and height is assumed to be 16 and 16 respectively
    ; calculate r2
    ld a, d
    add a, $10
    ld l, a

    ; load l1
    ld a, b
    cp l

    jr c, .break

    ; calculate l2
    ld a, b
    add a, $08
    ld l, a

    ; load r1
    ld a, d
    cp l

    jr c, .break

    ; Player's character is meant to be 8 x 9
    pop hl
    pop de

    ld a, l
    add a, $06
    ld l, a
    ld a, h
    adc $00
    ld h, a

    inc d
    ld a, d
    cp e
    jr nz, .check_game_object

    ld a, 0
    ret

.break:
    ld a, 1
    pop hl
    pop de
    ret
; Project Beest
; Game Objects Controller
; Developed by Caio Souza Oliveira
; 01 Oct 2019

; Initialize Game Object
; a: Target game object index (0-15)
; de: game object position (d: X, e: Y)
; c: target game object sprite
goc_initialize_game_object:
    
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Note: In global_variables.z80 will holds the two halfs of the sprites in sequence.
    ; That's why hl is always incremented between each value loaded to the game object.
    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X
    ld a, d
    ld [hl], a
    inc hl

    ; Tile
    ld a, c
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X (+0x8)
    ld a, d
    add a, $08
    ld [hl], a
    inc hl

    ; Tile 2
    ; The four parts of game object (4 tiles) must be loaded in sequence in memory.
    ld a, c
    add a, $02
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ret

; Returns base address for target game object
; a: target game objecy
; hl: initial address of the game object register
goc_get_gameobject_address:
    cp a, $00
    ld hl, gobj_0
    ret z
    cp a, $01
    ld hl, gobj_1
    ret z
    cp a, $02
    ld hl, gobj_2
    ret z
    cp a, $03
    ld hl, gobj_3
    ret z
    cp a, $04
    ld hl, gobj_4
    ret z
    cp a, $05
    ld hl, gobj_5
    ret z
    cp a, $06
    ld hl, gobj_6
    ret z
    cp a, $07
    ld hl, gobj_7
    ret z 
    cp a, $08
    ld hl, gobj_8
    ret z
    cp a, $09
    ld hl, gobj_9
    ret z
    cp a, $0A
    ld hl, gobj_10
    ret z
    cp a, $0B
    ld hl, gobj_11
    ret z
    cp a, $0C
    ld hl, gobj_12
    ret z
    cp a, $0D
    ld hl, gobj_13
    ret z
    cp a, $0E
    ld hl, gobj_14
    ret z
    cp a, $0F
    ld hl, gobj_15
    ret z
    cp a, $10
    ld hl, gobj_16
    ret z
    cp a, $11
    ld hl, gobj_17
    ret z
    cp a, $12
    ld hl, gobj_18
    ret z
    cp a, $13
    ld hl, gobj_19
    ret z
    ld hl, gobj_20
    ret


; scroll all game objects by a given amount on X and Y based on camera movement
; e: amount in X
; d: amoint in Y
goc_scroll_game_objects:

    ld a, [gobj_total_game_objects]
    ; add the player's game object
    inc a
    ld c, a
    ld b, $00

.update_game_object:
    ; check whether A is the player character.
    ld a, [ram_player_character_id]
    cp b
    jr z, .skip

    ld a, b

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Adjust Positions
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
.skip:
    inc b
    ld a, b
    cp c
    ret z
    jr .update_game_object


; Detects collisiton between caracter 0 and character 
; d: X position
; e: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects:

    push af
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    pop af

    inc hl
    ld a, [hl]
    add a, d
    ; Add bounding box origin
    add a, $03
    ld b, a
    dec hl
    ld a, [hl]
    add a, e
    ; Add bounding box origin
    add a, $07
    ld c, a

    ld a, [gobj_total_game_objects]
    ; compensate for the player game object
    inc a
    cp $01
    jr z, .finalize

    ld e, a
    ld d, $00

.check_game_object:

    ld a, [ram_player_character_id]
    cp d
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de
    
    ld a, d

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    push de
    ; Y
    ld a, [hl]
    ld d, a

    inc hl
    ; X
    ld a, [hl]
    ld e, a

    ; Negative Check.
    ;
    ;   r1(X1, Y1)           
    ;   +------------------+
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   +------------------+
    ;                      r1(X2, Y2)
    ;                      X2 = X1 + 16
    ;                      Y2 = Y1 + 16

    ; if ((rect1.x < rect2.x + rect2.width &&
    ; rect1.x + rect1.width > rect2.x &&
    ; rect1.y < rect2.y + rect2.height &&
    ; rect1.y + rect1.height > rect2.y)) 
    
    ; condition 1
    ; calculate rect1.x < rect2.x + rect2.width
    push de
    ld a, e
    add a, $10
    ld e, a

    ld a, b
    cp e
    pop de
    jr nc, .continue

    ; condition 2
    ; calculate rect1.x + rect1.width > rect2.x
    push bc
    ld a, b
    add a, $0A
    ld b, a

    ld a, b
    cp e
    pop bc
    jr c, .continue
    jr z, .continue

    ; condition 3
    ; calculate rect1.y < rect2.y + rect2.height
    push de
    ld a, d
    add a, $10
    ld d, a

    ld a, c
    cp d
    pop de
    jr nc, .continue

    ; condition 4
    ; calculate rect1.y + rect1.height > rect2.y
    push bc
    ld a, c
    add a, $09
    ld c, a

    ld a, d
    add a, $07
    ld d, a
    ld a, c
    cp d
    pop bc
    jr c, .continue
    jr z, .continue

.break:
    pop de
    ld a, 1
    ret

.continue:
    pop de

    inc d
    ld a, e
    cp d
    jr nz, .check_game_object

.finalize:
    ld a, 0
    ret
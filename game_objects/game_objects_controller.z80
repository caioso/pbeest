; Project Beest
; Game Objects Controller
; Developed by Caio Souza Oliveira
; 01 Oct 2019

; Initializes game objec map table
goc_initialize_game_object_usage_table:
    push hl
    push de
    ld hl, gobj_usage_table
    ld d, $00
.continue:
    ld a, $FF
    ld [hl], a
    inc hl
    inc d
    ld a, d
    cp 20
    jr nz, .continue
    pop de
    pop hl
    ret

; Normalize game objec map table
goc_normalize_game_object_usage_table:
    push hl
    push de
    ld hl, gobj_usage_table
    ld d, $00
.continue:
    ld a, [hl]
    cp $AA
    jr nz, .skip_cleanup
        ld a, $00
        ld [hl], a

.skip_cleanup:
    inc hl
    inc d
    ld a, d
    cp 20
    jr nz, .continue
    pop de
    pop hl
    ret

; Initialize Game Object
; a: Target game object index (0-15)
; de: game object position (d: X, e: Y)
; c: target game object sprite
; b: Is the initialization meant for map loading?
goc_initialize_game_object:

    ; set table
    push af
    ld hl, gobj_table
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a
    ld [hl], game_object_taken
    pop af

    ; mark goc in usage table
    push af
    ld hl, gobj_usage_table
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; Load the table with the value of AA (generic marker) into hl
    ld a, b
    cp $00
    jr z, .load_zero
        ld a, $AA
        jr .load_marker
.load_zero:
        ld a, $00
.load_marker:
    ld [hl], a
    pop af

    push af
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ld a, b
    cp $00
    jp z, .clear_af

    push hl
    call map_get_map_origin_offset

    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .scroll_right
        ld a, l
        sub $A0
        add d
        ld d, a
        ld a, h
        add e
        ld e, a
        jr .continue
.scroll_right:
        push hl
        ld l, map_load_right
        call check_animation_direction
        pop hl
        jr nz, .scroll_up
            ld a, l
            add $90
            add d
            ld d, a
            ld a, h
            add e
            ld e, a
            jr .continue
.scroll_up:
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        jr nz, .scroll_down
            ld a, h
            sub $90
            add e
            ld e, a
            ld a, l
            add d
            ld d, a
            jr .continue
.scroll_down:
        push hl
        ld l, map_load_below
        call check_animation_direction
        pop hl
        jr nz, .no_scroll
            ld a, h
            add $90
            add e
            ld e, a
            ld a, l
            add d
            ld d, a
            jr .continue
.no_scroll:
            ld a, h
            add e
            ld e, a
            ld a, l
            add d
            ld d, a
            jr .continue
.continue:
    pop hl
    pop af
    
    ; Check on-screen case
    push af
    ld a, $90
    cp e
    jr c, .finish

.check_x:
    pop af

    ; Check on-screen case
    push af
    ld a, $A0
    cp d
    jr c, .finish
    jr .mark_goj

.mark_goj:
    pop af

    push af
    push hl
    ld hl, gobj_usage_table
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a
    ; for now AA. Use another index to label the game to remove it from the transition.
    ld a, $BB
    ld [hl], a
    pop hl
    pop af

    ld a, $00
    ld d, a
    ld e, a
    jr .skip_position_adjustment
    
.finish:
    pop af
    jr .skip_position_adjustment

.clear_af:
    pop af

.skip_position_adjustment:
    ; Note: In global_variables.z80 will holds the two halfs of the sprites in sequence.
    ; That's why hl is always incremented between each value loaded to the game object.
    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X
    ld a, d
    ld [hl], a
    inc hl

    ; Tile
    ld a, c
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X (+0x8)
    ld a, d
    cp $00
    jr z, .skip_extra
    add a, $08
.skip_extra:
    ld [hl], a
    inc hl

    ; Tile 2
    ; The four parts of game object (4 tiles) must be loaded in sequence in memory.
    ld a, c
    add a, $02
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; load total game objects in the map
    ld a, [gobj_total_game_objects]
    inc a
    ld [gobj_total_game_objects], a

    ret

; Clears game object, based on its postiion.
; a: game object index
goc_clear_game_object:
    push bc
    ld b, a

    ld hl, gobj_table
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a
    ld a, $FF
    ld [hl], a

    ld a, b
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ld a, $00
    ld [hl], a
    inc hl

    ; X
    ld [hl], a
    inc hl

    ; Tile
    ld [hl], a
    inc hl

    ; Attribute
    ld [hl], a
    inc hl

    ; Y
    ld [hl], a
    inc hl

    ; X
    ld [hl], a
    inc hl

    ld [hl], a
    inc hl

    ; Attribute
    ld [hl], a
    inc hl

    ; load total game objects in the map
    ld a, [gobj_total_game_objects]
    cp $00
    jr z, .skip
        dec a
        ld [gobj_total_game_objects], a

.skip:
    pop bc

    ret

; Returns base address for target game object
; a: target game objecy
; hl: initial address of the game object register
goc_get_gameobject_address:
    cp a, $00
    ld hl, gobj_0
    ret z
    cp a, $01
    ld hl, gobj_1
    ret z
    cp a, $02
    ld hl, gobj_2
    ret z
    cp a, $03
    ld hl, gobj_3
    ret z
    cp a, $04
    ld hl, gobj_4
    ret z
    cp a, $05
    ld hl, gobj_5
    ret z
    cp a, $06
    ld hl, gobj_6
    ret z
    cp a, $07
    ld hl, gobj_7
    ret z 
    cp a, $08
    ld hl, gobj_8
    ret z
    cp a, $09
    ld hl, gobj_9
    ret z
    cp a, $0A
    ld hl, gobj_10
    ret z
    cp a, $0B
    ld hl, gobj_11
    ret z
    cp a, $0C
    ld hl, gobj_12
    ret z
    cp a, $0D
    ld hl, gobj_13
    ret z
    cp a, $0E
    ld hl, gobj_14
    ret z
    cp a, $0F
    ld hl, gobj_15
    ret z
    cp a, $10
    ld hl, gobj_16
    ret z
    cp a, $11
    ld hl, gobj_17
    ret z
    cp a, $12
    ld hl, gobj_18
    ret z
    cp a, $13
    ld hl, gobj_19
    ret z
    ld hl, gobj_20
    ret

; Initializes Game Object table with 0xFF
goc_initialize_gobj_table:
    ld c, $00
    ld hl, gobj_table
    ld b, $FF
.next:
    ld a, b
    ld [hl], a
    inc hl
    inc c
    ld a, 20
    cp c
    jr nz, .next
    ret

; Finds a slot in the game object table
; return a: target game objhecr index
goc_find_game_object_table_slot:
    push bc
    push hl
    ld c, $00
    ld hl, gobj_table
.next:
    ld a, [hl]
    cp a, $FF
    ld a, c
    jr z, .finish

    inc hl
    inc c
    ld a, 20
    cp c
    jr nz, .next

    ; if running this line, no slots have been fond
    ld a, $FF

.finish:
    pop hl
    pop bc
    ret
 
    ret

; scroll all game objects by a given amount on X and Y based on camera movement
; e: amount in X
; d: amoint in Y
; b: is for transition? (1: will unload out of bounds GameObjects, 0: will not unload them)
goc_scroll_game_objects:
    
    ld a, [ram_general_use_variable_1]
    push af
    ld a, [ram_general_use_variable_2]
    push af

    ; save b
    ld a, b
    ld [ram_general_use_variable_2], a

    ld a, gobj_table_end - gobj_table
    ; add the player's game object
    inc a
    ld c, a
    ld b, $00

.update_game_object:
    ; initialize counter
    ld a, $00
    ld [ram_general_use_variable_1], a

    ld hl, gobj_table
    ld a, b
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; if $FF (game pbject has not been taken), skip
    ld a, [hl]
    cp $FF
    jr z, .skip

    ; check whether A is the player character.
    ld a, [ram_player_character_id]
    cp b
    jr z, .skip

    ld a, b

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Adjust Positions
    ld a, [hl]
    add a, d
    ld [hl], a
    ; Check whether Y is outside of the screen Height
    cp $90
    jr c, .continue_update_1
        ld a, $01
        ld [ram_general_use_variable_1], a

.continue_update_1:
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a

    ; Check whether X is outside of the screen Width
    cp $A0
    jr c, .continue_update_2
        ld a, $01
        ld [ram_general_use_variable_1], a

.continue_update_2:
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a

    ld hl, gobj_usage_table
    ld a, b
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a
    ld a, [hl]
    cp $AA
    jr z, .skip
    cp $BB
    jr z, .skip
    ld a, [ram_general_use_variable_2]
    cp $00
    jr z, .skip

    ; Check whether the game object in the list must be cleared
    ld a, [ram_general_use_variable_1]
    cp $01
    jr nz, .skip
        push hl
        ; clear the entry in the game object usage table
        ld hl, gobj_usage_table
        ld a, b
        add l
        ld l, a
        ld a, h
        adc $00
        ld h, a
        ; FF means the entry is not used. anything else means it has been taken.
        ld a, $FF
        ld [hl], a
        pop hl

        ; clear game object
        ld a, b
        call goc_clear_game_object
.skip:
    inc b
    ld a, b
    cp c
    jr z, .finish
    jr .update_game_object

.finish:
    pop af
    ld [ram_general_use_variable_2], a
    pop af
    ld [ram_general_use_variable_1], a
    ret

; Detects collisiton between character [ram_player_character_id] and character 
; d: X position
; e: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects:

    push af
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    pop af

    inc hl
    ld a, [hl]
    add a, d
    ; Add bounding box origin
    add a, $03
    ld b, a
    dec hl
    ld a, [hl]
    add a, e
    ; Add bounding box origin
    add a, $07
    ld c, a

    ld a, [gobj_total_game_objects]
    ; compensate for the player game object
    inc a
    cp $01
    jr z, .finalize

    ; load table size
    ld a, gobj_table_end - gobj_table

    ld e, a
    ld d, $00

.check_game_object:

    ld a, [ram_player_character_id]
    cp d
    
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de

    push hl
    ld hl, gobj_table
    ld a, d
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; if $FF (game pbject has not been taken), skip
    ld a, [hl]
    cp $FF
    pop hl
    
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de
    ld a, d

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    push de
    ; Y
    ld a, [hl]
    ld d, a

    inc hl
    ; X
    ld a, [hl]
    ld e, a

    ; Negative Check.
    ;
    ;   r1(X1, Y1)           
    ;   +------------------+
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   +------------------+
    ;                      r1(X2, Y2)
    ;                      X2 = X1 + 16
    ;                      Y2 = Y1 + 16

    ; if ((rect1.x < rect2.x + rect2.width &&
    ; rect1.x + rect1.width > rect2.x &&
    ; rect1.y < rect2.y + rect2.height &&
    ; rect1.y + rect1.height > rect2.y)) 
    
    ; condition 1
    ; calculate rect1.x < rect2.x + rect2.width
    push de
    ld a, e
    add a, $10
    ld e, a

    ld a, b
    cp e
    pop de
    jr nc, .continue

    ; condition 2
    ; calculate rect1.x + rect1.width > rect2.x
    push bc
    ld a, b
    add a, $0A
    ld b, a

    ld a, b
    cp e
    pop bc
    jr c, .continue
    jr z, .continue

    ; condition 3
    ; calculate rect1.y < rect2.y + rect2.height
    push de
    ld a, d
    add a, $10
    ld d, a

    ld a, c
    cp d
    pop de
    jr nc, .continue

    ; condition 4
    ; calculate rect1.y + rect1.height > rect2.y
    push bc
    ld a, c
    add a, $09
    ld c, a

    ld a, d
    add a, $07
    ld d, a
    ld a, c
    cp d
    pop bc
    jr c, .continue
    jr z, .continue

.break:
    pop de

    ; set collision target
    ld a, d
    ld [collision_target], a
    
    ; set collision type
    ld a, collision_type_gob
    ld [collision_target_type], a
    
    ld a, 1
    ret

.continue:
    pop de

    inc d
    ld a, 20
    cp d
    jr nz, .check_game_object

.finalize:
    ld a, 0
    ret

; Detects collisiton between character [ram_player_character_id] and character. This intended primarily to adjust z-index
; d: X position
; e: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects_full_obj:

    push af
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    pop af

    inc hl
    ld a, [hl]
    add a, d
    ; Add bounding box origin
    ;add a, $03
    ld b, a
    dec hl
    ld a, [hl]
    add a, e
    ; Add bounding box origin
    ;add a, $07
    ld c, a

    ld a, [gobj_total_game_objects]
    ; compensate for the player game object
    inc a
    cp $01
    jr z, .finalize

    ld e, a
    ld d, $00

.check_game_object:

    ld a, [ram_player_character_id]
    cp d
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de
    
    push hl
    ld hl, gobj_table
    ld a, d
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; if $FF (game pbject has not been taken), skip
    ld a, [hl]
    cp $FF
    pop hl
    
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de

    ld a, d

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    push de
    ; Y
    ld a, [hl]
    ld d, a

    inc hl
    ; X
    ld a, [hl]
    ld e, a

    ; Negative Check.
    ;
    ;   r1(X1, Y1)           
    ;   +------------------+
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   +------------------+
    ;                      r1(X2, Y2)
    ;                      X2 = X1 + 16
    ;                      Y2 = Y1 + 16

    ; if ((rect1.x < rect2.x + rect2.width &&
    ; rect1.x + rect1.width > rect2.x &&
    ; rect1.y < rect2.y + rect2.height &&
    ; rect1.y + rect1.height > rect2.y)) 
    
    ; condition 1
    ; calculate rect1.x < rect2.x + rect2.width
    push de
    ld a, e
    add a, $10
    ld e, a

    ld a, b
    cp e
    pop de
    jr nc, .continue

    ; condition 2
    ; calculate rect1.x + rect1.width > rect2.x
    push bc
    ld a, b
    add a, $10
    ld b, a

    ld a, b
    cp e
    pop bc
    jr c, .continue
    jr z, .continue

    ; condition 3
    ; calculate rect1.y < rect2.y + rect2.height
    push de
    ld a, d
    add a, $10
    ld d, a

    ld a, c
    cp d
    pop de
    jr nc, .continue

    ; condition 4
    ; calculate rect1.y + rect1.height > rect2.y
    push bc
    ld a, c
    add a, $10
    ld c, a

    ld a, d
    ;add a, $10
    ld d, a
    ld a, c
    cp d
    pop bc
    jr c, .continue
    jr z, .continue

.break:
    pop de
    
    ; Swap game Objects Based on Position
    call goc_adjust_z_index

    ld a, 1
    ret

.continue:
    pop de

    inc d
    ; check if all game objects have been checked
    ld a, 20
    cp d
    jr nz, .check_game_object

.finalize:
    ld a, 0
    ret

; Adjust two game objects z-index based on their Y-position
; d: target game object
goc_adjust_z_index:
    ; save d for later
    ld c, d

    ld a, d
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address
    
    ; Load Y position of target game object into e
    ld a, [hl]
    ld e, a

    ; load player game object
    ld a, [ram_player_character_id] 
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Load Y position of player's game object into d
    ld a, [hl]
    ld d, a

    ; compare position to determine the game object position
    cp e
    ; player game objects is below the target game object
    jr c, .is_above
    ; in thise case the player game object must be above (z index lower)
    ld a, [ram_player_character_id]
    cp c
    
    ; if not carry (positive), then swap it. oterwise, return
    ret c
    ld a, [ram_player_character_id]
    ld b, a
    push bc
    push de
    push hl
    call goc_swap_gameobject_by_index
    pop hl
    pop de
    pop bc

    ; update player's id 
    ld a, c
    ld [ram_player_character_id], a
    ret

.is_above:
    ; in thise case the player game object must be above (z index lower)
    ld a, [ram_player_character_id]
    cp c
    
    ; if not carry (positive), then swap it. oterwise, return
    ret nc
    ld a, [ram_player_character_id]
    ld b, a
    push bc
    push de
    push hl
    call goc_swap_gameobject_by_index
    pop hl
    pop de
    pop bc

    ; update player's id 
    ld a, c
    ld [ram_player_character_id], a
    ret

    ret

; Swap two game objects by index
; c: game object index 1
; b: game object index 2
goc_swap_gameobject_by_index:
    
    ld a, c
    call goc_get_gameobject_address
    ld d, h
    ld e, l

    ld a, b
    call goc_get_gameobject_address

    ld b, $00
.continue_copy:
    ld a, [hl]
    ld [temp_gobj_y], a
    ld a, [de]
    ld [hl], a
    ld a, [temp_gobj_y]
    ld [de], a
    inc hl
    inc de
    inc b
    ld a, b
    cp $08
    jr nz, .continue_copy
    ret
; Project Beest
; Game Objects Controller
; Developed by Caio Souza Oliveira
; 01 Oct 2019

; Initialize Game Object
; a: Target game object index (0-15)
; de: game object position (d: X, e: Y)
; c: target game object sprite
; d: Is the initialization meant for map loading?
goc_initialize_game_object:
    
    ; set table
    push af
    ld hl, gobj_table
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a
    ld [hl], game_object_taken
    pop af

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ld a, b
    cp $01
    jr nz, .skip_position_adjustment
        ; Adjust Position based on the flag stored in d    
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        jr nz, .load_below
            ld a, e
            sub a, $90 ; 144 pixels above
            ld e, a
            jr .skip_position_adjustment
.load_below:     
        push hl
        ld l, map_load_below
        call check_animation_direction
        pop hl
        jr nz, .load_left
            ld a, e
            add a, $90 ; 144 pixels above
            ld e, a
            jr .skip_position_adjustment

.load_left:     
        push hl
        ld l, map_load_left
        call check_animation_direction
        pop hl
        jr nz, .load_right
            ; What's gonna happen next:
            ; Since the game object has to be scrolled as it appear on screen (and the positions are always positive in the game boy)
            ; it is necessary to add a negartive cap to the position of the target game object.
            ; This is calculated as follows:
            ; Po(x) = (0xFF - (ScreenX - MapInitialX)*0x08) + 1 + (GameObject.x + 0x08);
            push hl
            ld a, $00
            call map_get_map_origin_X_offset
            ld a, l
            pop hl
            add d
            ld d, a

            jr .skip_position_adjustment

.load_right:     
        push hl
        ld l, map_load_right
        call check_animation_direction
        pop hl
        jr nz, .skip_position_adjustment
            push hl
            ; Offset Right
            ld a, $01
            call map_get_map_origin_X_offset
            ld a, l
            pop hl
            add d
            ld d, a


.skip_position_adjustment:
    ; Note: In global_variables.z80 will holds the two halfs of the sprites in sequence.
    ; That's why hl is always incremented between each value loaded to the game object.
    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X
    ld a, d
    ld [hl], a
    inc hl

    ; Tile
    ld a, c
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; Y
    ld a, e
    ld [hl], a
    inc hl

    ; X (+0x8)
    ld a, d
    add a, $08
    ld [hl], a
    inc hl

    ; Tile 2
    ; The four parts of game object (4 tiles) must be loaded in sequence in memory.
    ld a, c
    add a, $02
    ld [hl], a
    inc hl

    ; Attribute
    ld a, $00
    ld [hl], a
    inc hl

    ; load total game objects in the map
    ld a, [gobj_total_game_objects]
    inc a
    ld [gobj_total_game_objects], a

    ret

; Returns base address for target game object
; a: target game objecy
; hl: initial address of the game object register
goc_get_gameobject_address:
    cp a, $00
    ld hl, gobj_0
    ret z
    cp a, $01
    ld hl, gobj_1
    ret z
    cp a, $02
    ld hl, gobj_2
    ret z
    cp a, $03
    ld hl, gobj_3
    ret z
    cp a, $04
    ld hl, gobj_4
    ret z
    cp a, $05
    ld hl, gobj_5
    ret z
    cp a, $06
    ld hl, gobj_6
    ret z
    cp a, $07
    ld hl, gobj_7
    ret z 
    cp a, $08
    ld hl, gobj_8
    ret z
    cp a, $09
    ld hl, gobj_9
    ret z
    cp a, $0A
    ld hl, gobj_10
    ret z
    cp a, $0B
    ld hl, gobj_11
    ret z
    cp a, $0C
    ld hl, gobj_12
    ret z
    cp a, $0D
    ld hl, gobj_13
    ret z
    cp a, $0E
    ld hl, gobj_14
    ret z
    cp a, $0F
    ld hl, gobj_15
    ret z
    cp a, $10
    ld hl, gobj_16
    ret z
    cp a, $11
    ld hl, gobj_17
    ret z
    cp a, $12
    ld hl, gobj_18
    ret z
    cp a, $13
    ld hl, gobj_19
    ret z
    ld hl, gobj_20
    ret

; Initializes Game Object table with 0xFF
goc_initialize_gobj_table:
    ld c, $00
    ld hl, gobj_table
    ld b, $FF
.next:
    ld a, b
    ld [hl], a
    inc hl
    inc c
    ld a, 20
    cp c
    jr nz, .next
    ret

; Finds a slot in the game object table
; return a: target game objhecr index
goc_find_game_object_table_slot:
    push bc
    push hl
    ld c, $00
    ld hl, gobj_table
.next:
    ld a, [hl]
    cp a, $FF
    ld a, c
    jr z, .finish

    inc hl
    inc c
    ld a, 20
    cp c
    jr nz, .next

    ; if running this line, no slots have been fond
    ld a, $FF

.finish:
    pop hl
    pop bc
    ret
 
    ret

; scroll all game objects by a given amount on X and Y based on camera movement
; e: amount in X
; d: amoint in Y
goc_scroll_game_objects:

    ld a, gobj_table_end - gobj_table
    ; add the player's game object
    inc a
    ld c, a
    ld b, $00

.update_game_object:

    ld hl, gobj_table
    ld a, b
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; if $FF (game pbject has not been taken), skip
    ld a, [hl]
    cp $FF
    jr z, .skip

    ; check whether A is the player character.
    ld a, [ram_player_character_id]
    cp b
    jr z, .skip

    ld a, b

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Adjust Positions
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, d
    ld [hl], a
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
.skip:
    inc b
    ld a, b
    cp c
    ret z
    jr .update_game_object


; Detects collisiton between character [ram_player_character_id] and character 
; d: X position
; e: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects:

    push af
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    pop af

    inc hl
    ld a, [hl]
    add a, d
    ; Add bounding box origin
    add a, $03
    ld b, a
    dec hl
    ld a, [hl]
    add a, e
    ; Add bounding box origin
    add a, $07
    ld c, a

    ld a, [gobj_total_game_objects]
    ; compensate for the player game object
    inc a
    cp $01
    jr z, .finalize

    ; load table size
    ld a, gobj_table_end - gobj_table

    ld e, a
    ld d, $00

.check_game_object:

    ld a, [ram_player_character_id]
    cp d
    
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de

    push hl
    ld hl, gobj_table
    ld a, d
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; if $FF (game pbject has not been taken), skip
    ld a, [hl]
    cp $FF
    pop hl
    
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de
    ld a, d

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    push de
    ; Y
    ld a, [hl]
    ld d, a

    inc hl
    ; X
    ld a, [hl]
    ld e, a

    ; Negative Check.
    ;
    ;   r1(X1, Y1)           
    ;   +------------------+
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   +------------------+
    ;                      r1(X2, Y2)
    ;                      X2 = X1 + 16
    ;                      Y2 = Y1 + 16

    ; if ((rect1.x < rect2.x + rect2.width &&
    ; rect1.x + rect1.width > rect2.x &&
    ; rect1.y < rect2.y + rect2.height &&
    ; rect1.y + rect1.height > rect2.y)) 
    
    ; condition 1
    ; calculate rect1.x < rect2.x + rect2.width
    push de
    ld a, e
    add a, $10
    ld e, a

    ld a, b
    cp e
    pop de
    jr nc, .continue

    ; condition 2
    ; calculate rect1.x + rect1.width > rect2.x
    push bc
    ld a, b
    add a, $0A
    ld b, a

    ld a, b
    cp e
    pop bc
    jr c, .continue
    jr z, .continue

    ; condition 3
    ; calculate rect1.y < rect2.y + rect2.height
    push de
    ld a, d
    add a, $10
    ld d, a

    ld a, c
    cp d
    pop de
    jr nc, .continue

    ; condition 4
    ; calculate rect1.y + rect1.height > rect2.y
    push bc
    ld a, c
    add a, $09
    ld c, a

    ld a, d
    add a, $07
    ld d, a
    ld a, c
    cp d
    pop bc
    jr c, .continue
    jr z, .continue

.break:
    pop de

    ; set collision target
    ld a, d
    ld [collision_target], a
    
    ; set collision type
    ld a, collision_type_gob
    ld [collision_target_type], a
    
    ld a, 1
    ret

.continue:
    pop de

    inc d
    ld a, e
    cp d
    jr nz, .check_game_object

.finalize:
    ld a, 0
    ret

; Detects collisiton between character [ram_player_character_id] and character. This intended primarily to adjust z-index
; d: X position
; e: Y Position
; a: 1 - collision happened; 0 - no collision happened
goc_detect_collision_width_game_objects_full_obj:

    push af
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    pop af

    inc hl
    ld a, [hl]
    add a, d
    ; Add bounding box origin
    ;add a, $03
    ld b, a
    dec hl
    ld a, [hl]
    add a, e
    ; Add bounding box origin
    ;add a, $07
    ld c, a

    ld a, [gobj_total_game_objects]
    ; compensate for the player game object
    inc a
    cp $01
    jr z, .finalize

    ld e, a
    ld d, $00

.check_game_object:

    ld a, [ram_player_character_id]
    cp d
    ; align stack (continue will pop de)
    push de
    jr z, .continue
    pop de
    
    ld a, d

    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    push de
    ; Y
    ld a, [hl]
    ld d, a

    inc hl
    ; X
    ld a, [hl]
    ld e, a

    ; Negative Check.
    ;
    ;   r1(X1, Y1)           
    ;   +------------------+
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   |                  |
    ;   +------------------+
    ;                      r1(X2, Y2)
    ;                      X2 = X1 + 16
    ;                      Y2 = Y1 + 16

    ; if ((rect1.x < rect2.x + rect2.width &&
    ; rect1.x + rect1.width > rect2.x &&
    ; rect1.y < rect2.y + rect2.height &&
    ; rect1.y + rect1.height > rect2.y)) 
    
    ; condition 1
    ; calculate rect1.x < rect2.x + rect2.width
    push de
    ld a, e
    add a, $10
    ld e, a

    ld a, b
    cp e
    pop de
    jr nc, .continue

    ; condition 2
    ; calculate rect1.x + rect1.width > rect2.x
    push bc
    ld a, b
    add a, $10
    ld b, a

    ld a, b
    cp e
    pop bc
    jr c, .continue
    jr z, .continue

    ; condition 3
    ; calculate rect1.y < rect2.y + rect2.height
    push de
    ld a, d
    add a, $10
    ld d, a

    ld a, c
    cp d
    pop de
    jr nc, .continue

    ; condition 4
    ; calculate rect1.y + rect1.height > rect2.y
    push bc
    ld a, c
    add a, $10
    ld c, a

    ld a, d
    ;add a, $10
    ld d, a
    ld a, c
    cp d
    pop bc
    jr c, .continue
    jr z, .continue

.break:
    pop de
    
    ; Swap game Objects Based on Position
    call goc_adjust_z_index

    ld a, 1
    ret

.continue:
    pop de

    inc d
    ld a, e
    cp d
    jr nz, .check_game_object

.finalize:
    ld a, 0
    ret

; Adjust two game objects z-index based on their Y-position
; d: target game object
goc_adjust_z_index:
    ; save d for later
    ld c, d

    ld a, d
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address
    
    ; Load Y position of target game object into e
    ld a, [hl]
    ld e, a

    ; load player game object
    ld a, [ram_player_character_id] 
    ; After calling goc_get_gameobject_address, hl holds the address to the target game object sprite
    call goc_get_gameobject_address

    ; Load Y position of player's game object into d
    ld a, [hl]
    ld d, a

    ; compare position to determine the game object position
    cp e
    ; player game objects is below the target game object
    jr c, .is_above
    ; in thise case the player game object must be above (z index lower)
    ld a, [ram_player_character_id]
    cp c
    
    ; if not carry (positive), then swap it. oterwise, return
    ret c
    ld a, [ram_player_character_id]
    ld b, a
    push bc
    push de
    push hl
    call goc_swap_gameobject_by_index
    pop hl
    pop de
    pop bc

    ; update player's id 
    ld a, c
    ld [ram_player_character_id], a
    ret

.is_above:
    ; in thise case the player game object must be above (z index lower)
    ld a, [ram_player_character_id]
    cp c
    
    ; if not carry (positive), then swap it. oterwise, return
    ret nc
    ld a, [ram_player_character_id]
    ld b, a
    push bc
    push de
    push hl
    call goc_swap_gameobject_by_index
    pop hl
    pop de
    pop bc

    ; update player's id 
    ld a, c
    ld [ram_player_character_id], a
    ret

    ret

; Swap two game objects by index
; c: game object index 1
; b: game object index 2
goc_swap_gameobject_by_index:
    
    ld a, c
    call goc_get_gameobject_address
    ld d, h
    ld e, l

    ld a, b
    call goc_get_gameobject_address

    ld b, $00
.continue_copy:
    ld a, [hl]
    ld [temp_gobj_y], a
    ld a, [de]
    ld [hl], a
    ld a, [temp_gobj_y]
    ld [de], a
    inc hl
    inc de
    inc b
    ld a, b
    cp $08
    jr nz, .continue_copy
    ret
include "inc/gbhw.inc"                      ; import file definitions 

; Sprite-related constants
sprite_0_y equ _OAMRAM ; first byte of sprite memory holds the Y position of sprite 0
sprite_0_x equ _OAMRAM + 1
sprite_0_tile equ _OAMRAM + 2
sprite_0_att equ _OAMRAM + 3

; Control Variables
movx equ _RAM
movy equ _RAM + 1
pad equ _RAM + 2 
current_palette equ _RAM + 3
window_state equ _RAM + 4
window_y equ _RAM + 5
arg0 equ _RAM + 6
window_anim equ _RAM + 7

section "start", ROM0[$0100]
    nop
    jp main

    ; header definition
    ROM_HEADER  ROM_MBC2, ROM_SIZE_2MBYTE, RAM_SIZE_128KBYTE

; main function
main:
    nop
    di
    ld sp, $ffff

bootup:
    ld a, %11100100     ; loading pallette
    ld [rBGP], a        ; right to the pallete register
    ld [rOBP0], a       ; right to the pallete 0 register

    ld a, %00011011     ; loading pallette
    ld [rOBP1], a       ; right to the pallete 1register

    ld a, 0
    ld [rSCX], a        ; scrol 0 (X)
    ld [rSCY], a        ; scrol 0 (Y)

    ld a, 7
    ld [rWX], a
    ld a, 144
    ld [window_y], a
    ld [rWY], a
    ld a, 0
    ld [window_anim], a

    call clear_lcd      ; clear screen

    ld hl, Tiles        ; load address of tile TFace
    ld de, _VRAM        ; load address of video memory
    ld b, Tiles_end - Tiles            ; amount of bytes to copy

.tile_load_routine:
    ld a, [hl]              ; load content @ address pointed by HL
    ld [de], a              ; load the byte in a to the address tored in de
    dec b                   ; one byte has been sent (subtract 1 from the total)
    jr z, .tile_loaded       ; leave if b is 0 (all bytes sent to VRAM)
    inc hl                  ; else, increment hl (next address in the TFace tile bytes)
    inc de                  ; increment the address in VRAM
    jr .tile_load_routine
.tile_loaded:

    ; set window mode
    ld a, 0
    ld [window_state], a

    ld hl, arg0
    ld [hl], $00
    ld hl, _SCRN0 - 1       ; load address of background map
    call start_map          ; initialize background
    ld hl, arg0
    ld [hl], $02
    ld hl, _SCRN1 - 1       ; load address of window map
    call start_map          ; initialize window
    
    call clear_sprite_data

    ; Sprite Data Initialziation
    ld a, 30
    ld [sprite_0_y], a  ; position Y of sprite 0
    ld a, 30
    ld [sprite_0_x], a  ; position X of sprite 0
    ld a, 1
    ld [sprite_0_tile], a   ; tile number
    ld a, 1
    ld [sprite_0_att], a    ; no sprite attributes
    ld [current_palette], a ; initialize current pallete as 0;

    ld a, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON|LCDCF_WIN9C00
    ld      [rLCDC], a
 
    ; Check input and move character accordingly
    call read_joypad

    ; Main Loop
main_loop:
    ; Wait for VRAM to change graphics

.wait_vram:
    ld a, [rLY]
    cp 145
    jr nz, .wait_vram

    call read_joypad ; Read joypad
    call wait

    ld a, [pad]
    and a, %00010000    ; right
    jr z, .skip_right
    ld a, [sprite_0_x]
    add a, $1
    ld hl, sprite_0_x
    ld [hl], a
.skip_right:

    ld a, [pad]
    and a, %00100000    ; right
    jr z, .skip_left
    ld a, [sprite_0_x]
    sub a, $1
    ld hl, sprite_0_x
    ld [hl], a
.skip_left:
    
    ld a, [pad]
    and a, %01000000    ; up
    jr z, .skip_up
    ld a, [sprite_0_y]
    sub a, $1
    ld hl, sprite_0_y
    ld [hl], a
.skip_up:

    ld a, [pad]
    and a, %10000000    ; down
    jr z, .skip_down
    ld a, [sprite_0_y]
    add a, $1
    ld hl, sprite_0_y
    ld [hl], a
.skip_down:

    ld a, [pad]
    and a, %00000001   ; A
    jr z, .skip_a
    call change_palette
.skip_a:

    call reset_position
.reset_position:

    ld a, [pad]
    and a, %00001000    ; start
    jr z, .skip_start
    call show_window

    ; check_win anim
    ld a, [window_anim]
    ld d, 1
    and a, d
    jr z, .skip_start
    call show_window
.skip_start

    jr main_loop

change_palette:
    ld a, [current_palette]
    and %00000001
    jr z, .set_palette_0
    ld a, [sprite_0_att]
    set 4, a
    ld [sprite_0_att], a
    ld a, 0
    ld [current_palette], a
    call wait
    jr .end_palette_set
.set_palette_0:
    ld a, [sprite_0_att]
    res 4, a
    ld [sprite_0_att], a
    ld a, 1
    ld [current_palette], a
    call wait
.end_palette_set:
    ret

reset_position:
    ld a, [pad]
    and a, %00000010
    jr z, .reset_position_end
    ld a, 30
    ld [sprite_0_x], a
    ld [sprite_0_y], a
    ld [movx], a
    ld [movy], a
.reset_position_end:
    ret

clear_lcd:
    ld a, [rLCDC]
    rlca                ; set higher bit of LCDC in the carry bit 
    ret nc

.wait_VBLANK
    ld      a, [rLY]
    cp      145
    jr      nz, .wait_VBLANK
 
    ; estamos en VBlank, apagamos el LCD
    ld      a,[rLCDC]       ; en A, el contenido del LCDC
    res     7,a             ; ponemos a cero el bit 7 (activado del LCD)
    ld      [rLCDC],a       ; escribimos en el registro LCDC el contenido de A
 
    ret                     ; volvemos

clear_sprite_data:
    ld c, 40
    ld hl, _OAMRAM
.begin:
    ld a, 0
    ld [hl], a  ; position Y of sprite 0
    inc hl
    ld a, 0
    ld [hl], a  ; position X of sprite 0
    inc hl
    ld a, 0
    ld [hl], a   ; tile number
    inc hl
    ld a, 0
    ld [hl], a    ; no sprite attributes
    inc hl
    dec c
    ld a, 0
    or a, c
    jr nz, .begin
    ret

read_joypad:
    ; vamos a leer la cruzeta:
    ld      a, %00100000    ; bit 4 a 0, bit 5 a 1 (cruzeta activada, botones no)
    ld      [rP1], a
 
    ; ahora leemos el estado de la cruzeta, para evitar el bouncing
    ; hacemos varias lecturas
    ld      a, [rP1]
    ld      a, [rP1]
    ld      a, [rP1]
    ld      a, [rP1]
 
    and     $0F             ; solo nos importan los 4 bits de abajo.
    swap    a               ; intercambiamos parte baja y alta.
    ld      b, a            ; guardamos el estado de la cruzeta en b
 
    ; vamos a por los botones
    ld      a, %00010000    ; bit 4 a 1, bit 5 a 0 (botones activados, cruzeta no)
    ld      [rP1], a
 
    ; leemos varias veces para evitar el bouncing
    ld      a, [rP1]
    ld      a, [rP1]
    ld      a, [rP1]
    ld      a, [rP1]
 
    ; tenemos en A, el estado de los botones
    and     $0F             ; solo nos importan los 4 bits de abajo.
    or      b               ; hacemos un or con b, para "meter" en la parte
                            ; superior de A, el estado de la cruzeta.
 
    ; ahora tenemos en A, el estado de todo, hacemos el complemento y
    ; lo guardamos en la variable
    cpl
    ld      [pad], a
    ; volvemos
    ret
 

wait:
    ld a, $AA
    ld b, 0
.decrement_delay:
    dec a
    or b
    jr nz, .decrement_delay
    ret
    
start_map:
    ld de, 32*32
    ld b, 0
.load_bytes:
    ld a, l
    add a, 1
    ld l, a
    ld a, h
    adc a, 0
    ld h, a
    ld a, [arg0]
    ld [hl], a           ; write tile 0 to the first position of the map
    ld a, b
    add a, 1
    ld b, a
    cp a, 20
    jr nz, .dont_break_line
        ld a, l
        add a, 12
        ld l, a
        ld a, h
        adc a, 0
        ld h, a
        ld b, 0
.dont_break_line:
    dec de
    ld a, e ; Check if count is 0, since `dec bc` doesn't update flags
    or d
    jr z, .load_bytes_end
    jr .load_bytes
.load_bytes_end:
    ret

show_window:
    ; if (window_state == 1 && window_y != 144)
    ; return
    ld a, [window_state]
    ld d, a
    ld a, 1
    and d
    jr z, .second_window_check
    ld a, [window_y]
    ld d, a
    ld a, 10
    sub a, d
    jr nz, .continue
    jp .second_window_check
.continue
    ld a, [window_y]
    dec a
    ld [rWY], a
    ld [window_y], a
    ld d, 10
    sub a, d
    jr nz, .skip_clean_animation
    ld a, 0
    ld [window_anim], a
.skip_clean_animation:
    ret
.second_window_check:
    ld a, [window_state]
    ld d, a
    ld a, 1
    and d
    jr z, .display_window
    
    ld a, [rLCDC]
	and ~LCDCF_WINON
	;res		1, a
	ld [rLCDC], a
    ld a, 0
    ld [window_state], a 
    ld a, 1
    ld [window_anim], a
    jr .end_show_window
.display_window
    ld a, [rLCDC]
	or LCDCF_WINON
	;res		1, a
	ld [rLCDC], a
    ld a, 1
    ld [window_state], a
    ld a, 1
    ld [window_anim], a
.end_show_window:
    ret

; Demo Tile
Tiles:
    DB  $AA, $00, $44, $00, $AA, $00, $11, $00
    DB  $AA, $00, $44, $00, $AA, $00, $11, $00
    DB  $7C, $7C, $82, $FE, $82, $D6, $82, $D6
    DB  $82, $FE, $82, $BA, $82, $C6, $7C, $7C
    DB  $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
    DB  $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
Tiles_end:
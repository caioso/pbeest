; Project Beest
; Map Controller
; Developed by Caio Souza Oliveira
; 19 Aug 2019

; base tile memory base section address
map_tile_base_section_8000 equ 0
map_tile_base_section_9000 equ $20

map_initialize_map_controller:
    ld a, $00
    ld [map_current_x], a;
    ld [map_current_y], a;
    ld a, map_screen_width
    ld [map_current_width], a
    ld a, map_screen_height
    ld [map_current_height], a
    ret

; Calculate Rwal Map's Origin X and Y
map_calculate_map_real_positions:

    push bc
    ; Expression for left loading
    ; Real X = MAP X - (MAP X Offset)/8
    ; if RealX < 0 -> add 32 (wrap around)
    ld a, [map_current_x]
    ld c, a
    ; divide map current offset  by 3
    ld a, [map_current_x_offset]
    rrc a
    rrc a
    rrc a
    ld b, a
    ld a, c
    sub b
    ld c, a
    
    ld a, $80
    and c
    cp $00
    ld a, c
    jr z, .skip_test_left_x
        ld a, c
        add 32 ; Max Map Buffer Y
.skip_test_left_x:
    ld [map_real_x], a

    ; Real Y = MAP Y - (MAP Y Offset)/8
    ; if RealY < 0 -> add 32 (wrap around)
    ld a, [map_current_y]
    ld c, a
    ; divide map current offset  by 3
    ld a, [map_current_y_offset]
    rrc a
    rrc a
    rrc a
    ld b, a
    ld a, c
    sub b
    ld c, a
    
    ld a, $80
    and c
    cp $00
    ld a, c
    jr z, .skip_test_left_y
        ld a, c
        add 32 ; Max Map Buffer Y
.skip_test_left_y:
    ld [map_real_y], a
    pop bc
    ret

; Loads Room data (tiles, palletes and logic) at a specific position in the video buffer (video buffer size 32x32). With or without animations.
; *Important*: This method expects that a bank switching intention has been posted, with the target bank where the room code is located.
; hl: Room initial address
; a: animation & Data Loading Bit Map
;    bit 0: load palettes
;    bit 1: load tiles
;    bit [2:5]
;      0x00: No Animation
;      0x01: Left-to-Right
;      0x02: Right-to-Left
;      0x03: top-to-bottom
;      0x04: bottom-to-top
;    bit 6: base tile bank
; bc: initial tile address (full 16 bits tile address)
; de: map initial position X(d) and Y(e) [in tiles, not pixels]
map_load_room:
    ; save temp variables 
    ; save map data loading attributes bit map
    push hl
    ld hl, ram_general_use_variable_1
    ld [hl], a
    ld hl, ram_general_use_variable_2
    ld [hl], c
    ld hl, ram_general_use_variable_3
    ld [hl], b
    ld hl, ram_general_use_variable_15
    ld [hl], d
    ld hl, map_current_x_offset
    sla d
    sla d
    sla d
    ld [hl], d
    ld hl, ram_general_use_variable_16
    ld [hl], e
    ld hl, map_current_y_offset
    sla e
    sla e
    sla e
    ld [hl], e
    pop hl

    ; Load room metadata (save old map position)
    ; load map position X(d), Y(e)
    ; save original position
    push hl

    ; calculate tile map offset (based on initial address in VRAM)
    ; This is added to the room's tile LUT to find the correct tile ID for each entry in the room
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    bit 5, a
    jr z, .base_8000
        ld hl, $9000
        jr .continue_offset_tile_id_calculation
.base_8000:
        ld hl, $8000
.continue_offset_tile_id_calculation:
        ld a, c
        sub l
        ld e, a
        ld a, b
        sbc h
        ld d, a
        
        ;divide by 16 to get the correct tile offset (DE/BC)
        ld c, $10
        ld b, $00
        call div_DE_BC_DEBCu
        ; only the first byte of the division results matter (e)
        ld hl, ram_general_use_variable_4
        ld [hl], e

    pop hl

    ; hl holds the address of the room width byte
    ld de, map_current_width
    ld a, [hl]
    ld [de], a

    ; hl + 1 holds the address of the room height byte
    inc hl 
    ld de, map_current_height
    ld a, [hl]
    ld [de], a

    ; calculate total number of tiles at ram_general_use_variable_11/ram_general_use_variable_12
    call map_screen_width_times_screen_height

    ; load palette target bank (nothing to do for now)
    inc hl
    
    ; Palette loading routine
    ; step 1: check whether the palettes are meant to be loaded
    inc hl
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_palettes
    jr z, .skip_palette_load
        ; step 2: load tiles
        ; load initial palette address
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load total palettes
        inc hl
        ld a, [hl]
        
        ; room palettes (0-6) always start at 0
        ld bc, $00

        ; move de to hl (required as function argument)
        push hl
        ld l, e
        ld h, d

        ; move a to de
        ld e, a
        ld d, $00

        ; load palettes
        call bgc_load_background_palette
        pop hl
        jr .palette_loaded_skipped

.skip_palette_load:
    inc hl
    inc hl
.palette_loaded_skipped:
    ; load background tiles (not actual LUT but tile-patterns in VRAM)
    ; load palette target bank (nothing to do for now)
    inc hl

    ; Tile loading routine
    ; Check whether tiles should be loaded into VRAM and at which initial offset
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_tiles
    jr z, .skip_tiles_load
        ; load background tiles initial address
        inc hl
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load number of tiles
        inc hl
        ld a, [hl]
        ld c, a
        inc hl
        ld a, [hl]
        ld b, a

        ; move de to hl
        push hl
        ld l, e
        ld h, d
        
        ; configure rVBK to load tiles (a = 0)
        ld a, $00

        ; load initial tiles address
        push hl
        ld hl, ram_general_use_variable_2
        ld e, [hl]
        ld hl, ram_general_use_variable_3
        ld d, [hl]
        pop hl
        ; load tile initial address in 
        call tilecrt_load_tiles

        pop hl
        jr .tile_loaded_skipped

.skip_tiles_load:
    inc hl
    inc hl
    inc hl
    inc hl
.tile_loaded_skipped:
    ; is this one really needed? V
    inc hl

    ; save tile LUT initial address ram_general_use_variable_5, ram_general_use_variable_6
    ld a, l
    ld [map_current_LUT_address_byte_1], a
    ld [ram_general_use_variable_5], a
    ld a, h
    ld [map_current_LUT_address_byte_2], a
    ld [ram_general_use_variable_6], a

    ; Check the scrolling direction
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    ; Horizontal scrolling
    ; calculate first tile column 
    push hl
    call map_calculate_first_tile_column
    pop hl
    ; save first column to RAM (ram_general_use_variable_7)
    ld [ram_general_use_variable_7], a
    ; [ram_general_use_variable_12] holds the final X value to be stored in map_current_x
    ld [ram_general_use_variable_12], a
    ; only required for maps loaded to the left. Adjust 12 in case of wraparound

    call map_adjust_final_map_x
    call map_adjust_final_map_y

    ld a, [ram_general_use_variable_12]
    ld [map_current_x], a

    ; Calculate map's real X/Y
    call map_calculate_map_real_positions

    ; Load game objects
    push bc
    push de
    push hl
    call bac_jump_to_game_object_initializer
    pop hl
    pop de
    pop bc

    ; calculate first tile address in LUT
    call map_calculate_first_address_in_LUT_horizontal 
    ; save first address to be used later
    ld a, l
    ld [ram_general_use_variable_13], a
    ld a, h
    ld [ram_general_use_variable_14], a

    ; from this point onwards, HL holds the address of the first tile to be loaded

    ; prepare loop
    ; ram_general_use_variable_8: holds outer counter (width)
    ; ram_general_use_variable_9: holds inner counter (height)
    ; outer counter
    ld a, $00
    ld [ram_general_use_variable_8], a

    ; Recalculate room real dimensions
    call map_width_times_height

.tile_loading_outer_loop_horizontal:
    push hl
    ld a, [map_current_y_offset]
    srl a
    srl a
    srl a
    ld l, a
    ld a, [map_current_y]
    sub l

    ; 2's complement
    inc a
    cpl
    inc a
    ld l, a

    ; Compensate the result in the case of wrap around (subtract the result's 2's complement from the 32).
    ld a, 32
    sub l

    ld [ram_general_use_variable_9], a
    pop hl

    ld a, $00
    ld [ram_general_use_variable_17], a

.tile_loading_inner_loop_horizontal:

    ; calculate address offset within the LUT
    push de
    ld a,[ram_general_use_variable_5]
    ld e, a
    ld a,[ram_general_use_variable_6]
    ld d, a

    ; subtract HL from DE (DE holds the initial address of the LUT) in order to get only offsets
    ld a, l
    sub e
    ld e, a
    ld a, h
    sbc d
    ld d, a

    ; DE Holds the Offset within the LUT. Use it to find the position in both VRAM banks
    call map_load_tile_and_attribute_horizontal
    pop de

    ; add current width to HL
    ld a, [map_current_width]
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; inner loop boundary check    
    ld a, [ram_general_use_variable_9]
    inc a
    ld [ram_general_use_variable_9], a

    ld a, [ram_general_use_variable_17]
    inc a
    ld [ram_general_use_variable_17], a
    
    push hl
    ld l, a
    
    ; *NEW* Load the entire room at once
    ;ld a, map_screen_height
    ld a, [map_current_height]
    cp l
    pop hl
    jr nz, .tile_loading_inner_loop_horizontal

.complete_loading_column:
    ; outer loop boundary check
    ld a, [ram_general_use_variable_8]
    inc a
    ld [ram_general_use_variable_8], a
    push hl
    ld l, a

    ; Map width is guaranteed to be 20 tiles
    ; *NEW* load the entire room at once
    ;ld a, map_screen_width
    ld a, [map_current_width]
    cp l
    pop hl
    jr z, .complete_map_loading_horizontal
        ; prepare for the next iteration of the outer loop
        ; update column for the next iterations of the internal loop
        push hl
        ld l, map_load_left
        call check_animation_direction
        pop hl
        jr nz, .is_next_column_is_right
            ; Show appropriate scroll animation (left)
            push hl
            push bc
            ; check whether the amount of screen columns have been scrolled
            ld a, [ram_general_use_variable_8]
            sub map_screen_width
            jr nc, .skip_camera_movement_left
                ld a, 1
                call map_scroll_bg_horizontally_with_animation

.skip_camera_movement_left:
            pop bc
            pop hl
            jr .horizontal_animation_complete

.is_next_column_is_right:
            push hl
            push bc

            ld a, [ram_general_use_variable_8]
            sub map_screen_width
            jr nc, .skip_camera_movement_right
                ld a, 0
                call map_scroll_bg_horizontally_with_animation

.skip_camera_movement_right:
            pop bc
            pop hl

.horizontal_animation_complete:
        push hl
        ld l, map_load_left
        call check_animation_direction
        pop hl
        ld a, [ram_general_use_variable_7]
        jr nz, .increment_column
            dec a
            ld [ram_general_use_variable_7], a

            ;hl should point to the first element of the previous column
            ld a, [ram_general_use_variable_13]
            ld l, a
            ld a, [ram_general_use_variable_14]
            ld h, a
            dec hl
            ld a, l
            ld [ram_general_use_variable_13], a
            ld a, h
            ld [ram_general_use_variable_14], a

            jr .save_column
.increment_column:
            inc a
            ld [ram_general_use_variable_7], a

            ; hl should point to the first element of the next column
            ld a, [ram_general_use_variable_13]
            ld l, a
            ld a, [ram_general_use_variable_14]
            ld h, a
            inc hl
            ld a, l
            ld [ram_general_use_variable_13], a
            ld a, h
            ld [ram_general_use_variable_14], a
.save_column:   
        ; correct ram_general_use_variable_7 in case of wrap around
        call map_wrap_around_detector_horizontal
        jp .tile_loading_outer_loop_horizontal

.complete_map_loading_horizontal:

    ; last horizontal scroll after the map is complete loading
    push hl
    ld l, map_load_right
    call check_animation_direction
    pop hl
    jr nz, .scroll_left_h
        ld a, 0
        jr .last_scroll_h
.scroll_left_h:
        ld a, 1
.last_scroll_h:
        push hl
        push bc
        call map_scroll_bg_horizontally_with_animation
        pop bc
        pop hl

    ; Adjust Player Character Position
    push hl
    ld l, map_load_right
    call check_animation_direction
    pop hl
    jr nz, .final_left_position
        ; adjust offsets
        call map_adjust_character_offset

         ld a, $08
         push hl
         call ram_get_player_game_obj_address
         inc hl
         ld [hl], a
         pop hl
         add a, $08
         push hl
         call ram_get_player_game_obj_address
         call ram_get_sprite_second_half
         inc hl
         ld [hl], a
         pop hl

        jr .adjust_x_position
        ; For now ONLY left scroling screens will have offset (from screens coming from right, they will always have offset 0 (starting at 0))
.final_left_position:
        
        ; adjust offsets
        call map_adjust_character_offset

        ; only required for left-loaded screens
        ld a, $98
        push hl
        call ram_get_player_game_obj_address
        inc hl
        ld [hl], a
        pop hl
        add a, $08
        push hl
        call ram_get_player_game_obj_address
        call ram_get_sprite_second_half
        inc hl
        ld [hl], a
        pop hl

.adjust_x_position:

    ; Bring remaining game objects to screen
    call goc_bring_all_other_game_objects_to_screen

    ; load map logic layer
    call map_load_logic_layer

    ret

.vertical_scrolling:
    ; vertical scrolling
    ; calculate first tile row
    push hl
    call map_calculate_first_tile_row
    pop hl
    ; save first row to RAM (ram_general_use_variable_7)
    ld [ram_general_use_variable_7], a
    ; [ram_general_use_variable_12] holds the final Y value to be stored in map_current_y
    ld [ram_general_use_variable_12], a
    ; only required for upwards movement. Adjust 12 in case of wraparound
    call map_adjust_final_map_y
    call map_adjust_final_map_x

    ld a, [ram_general_use_variable_12]
    ld [map_current_y], a

    ; Calculate map's real X/Y
    call map_calculate_map_real_positions

    ; Load game objects
    push bc
    push de
    push hl
    call bac_jump_to_game_object_initializer
    pop hl
    pop de
    pop bc

    ; calculate first tile address in LUT
    call map_calculate_first_address_in_LUT_vertical
    ; from this point onwards, HL holds the address of the first tile to be loaded

    ; prepare loop
    ; ram_general_use_variable_8: holds outer counter (height)
    ; ram_general_use_variable_9: holds inner counter (width)
    ; outer counter
    ld a, $00
    ld [ram_general_use_variable_8], a

    ; Calculate room's real dimensions
    call map_width_times_height

.tile_loading_outer_loop_vertical:
    ; TODO: THE INTITIAL y VALUE SHOULD BE CALCULATED BASED ON THE SCREEN OFFSET, NOT ALWAYS 0.
    ; THIS IS ALSO VALID FOR VERTICAL SCREENS (IN THIS CASE THE x POSITION WILL BE CONSIDERED).
    ; ram_general_use_variable_9 holds the actual tile in VRAM, ram_general_use_variable_17 is the loop counter
    
    ; load as 0 for maos starting at origin.
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    cp a, $01
    jr nz, .adjust_position
        ; In this case, both ram_general_use_variable_9 and ram_general_use_variable_17 must start at 0
        ld a, $00
        jr .continue_variable_initialization
    
.adjust_position:
    push hl
    ld a, [map_current_x_offset]
    srl a
    srl a
    srl a
    ld l, a
    ld a, [map_current_x]
    sub l

    ; 2's complement
    inc a
    cpl
    inc a
    ld l, a

    ; Compensate the result in the case of wrap around (subtract the result's 2's complement from the 32).
    ld a, 32
    sub l
    pop hl

.continue_variable_initialization:
    ld [ram_general_use_variable_9], a

    ld a, $00
    ld [ram_general_use_variable_17], a

.tile_loading_inner_loop_vertical:
    ; calculate address offset within the LUT
    push de
    ld a,[ram_general_use_variable_5]
    ld e, a
    ld a,[ram_general_use_variable_6]
    ld d, a

    ; subtract HL from DE (DE holds the initial address of the LUT) in order to get only offsets
    ld a, l
    sub e
    ld e, a
    ld a, h
    sbc d
    ld d, a

    ; DE Holds the Offset within the LUT. Use it to find the position in both VRAM banks
    call map_load_tile_and_attribute_vertical
    pop de

    ; increment hl (move to the next element in the same row)
    inc hl

    ; inner loop boundary check
    ld a, [ram_general_use_variable_9]
    inc a
    ld [ram_general_use_variable_9], a

    ld a, [ram_general_use_variable_17]
    inc a
    ld [ram_general_use_variable_17], a

    push hl
    ld l, a

    ; Map width is guaranteed to be 20 tiles
    ; *NEW* Load the entire room at once
    ;ld a, map_screen_width
    ld a, [map_current_width]
    cp l
    pop hl
    jr nz, .tile_loading_inner_loop_vertical

.complete_loading_row:
    ; outer loop boundary check
    ld a, [ram_general_use_variable_8]
    inc a
    ld [ram_general_use_variable_8], a
    push hl
    ld l, a

    ; Map height is guaranteed to be 18 tiles
    ; *NEW* Load the entire room at once
    ;ld a, map_screen_height
    ld a, [map_current_height]
    cp l
    pop hl
    jp z, .complete_map_loading_vertical
        ; prepare for the next iteration of the outer loop
        ; update row for the next iterations of the internal loop
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        jr nz, .is_next_row_is_below
            ; check whether the maximum number of tiles have already been scrolled
            ld a, [ram_general_use_variable_8]
            sub map_screen_height
            jr nc, .skip_vertical_animation
                ; Show appropriate scroll animation (UP)
                push hl
                push bc
                ld a, 1
                call map_scroll_bg_vertically_with_animation
                pop bc
                pop hl
                jr .skip_vertical_animation

.is_next_row_is_below:
        ; Show appropriate scroll animation (DOWN)
        push hl
        ld l, map_load_origin
        call check_animation_direction
        pop hl
        jr z, .skip_vertical_animation
            ; check whether the maximum number of tiles have already been scrolled
            ld a, [ram_general_use_variable_8]
            sub map_screen_height
            jr nc, .skip_vertical_animation
                push hl
                push bc
                ld a, 0
                call map_scroll_bg_vertically_with_animation
                pop bc
                pop hl

.skip_vertical_animation:
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        ld a, [ram_general_use_variable_7]
        jr nz, .increment_row
            dec a
            ld [ram_general_use_variable_7], a

            ; Subtract the room width and the screen width to get to the next row above the current one
            push de
            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a

            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a
            pop de

            jr .save_row
.increment_row:
            inc a
            ld [ram_general_use_variable_7], a

            push de
            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            add e
            ld l, a
            ld a, h
            adc $00
            ld h, a

            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a
            pop de
.save_row:   
        ; correct ram_general_use_variable_7 in case of wrap around
        call map_wrap_around_detector
        jp .tile_loading_outer_loop_vertical

.complete_map_loading_vertical:
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jr nz, .scroll_on_last_time
        call map_scroll_bg_to_target_position_without_animation
        jr .map_load_complete
        
.scroll_on_last_time:
    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jr nz, .scroll_up
        ld a, 0
        jr .last_scroll
.scroll_up:
        ld a, 1
.last_scroll:
        push hl
        push bc
        call map_scroll_bg_vertically_with_animation
        pop bc
        pop hl

.map_load_complete:

    ; Adjust Player Character Position
    push hl
    ld l, map_load_origin
    call check_animation_direction
    ; adjust offsets
    call map_adjust_character_offset
    pop hl
    jr z, .load_logic

    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jr nz, .final_up_position
        ; adjust offsets
        ; call map_adjust_character_offset

         ld a, $10
         push hl
         call ram_get_player_game_obj_address
         ld [hl], a
         call ram_get_sprite_second_half
         ld [hl], a
         pop hl
         jr .adjust_y_position

.final_up_position:
        ; adjust offsets
        ; call map_adjust_character_offset

         ;ld a, $90
         ;push hl
         ;call ram_get_player_game_obj_address
         ;ld [hl], a
         ;call ram_get_sprite_second_half
         ;ld [hl], a
         ;pop hl

.adjust_y_position:
    ; push hl
    ; Adjust X position based on the map offsets
    ; This is no longer needed because of the use of DMA (the positions cannot be calculated in steps anymoer)
    ;ld a, [map_current_x_offset]
    ;ld l, a
    ;ld a, [character_0_x]
    ;add l
    ;ld [character_0_x], a
    
    ; Adjust Y position based on the map offsets
    ; This is no longer needed because of the use of DMA (the positions cannot be calculated in steps anymoer)
    ;ld a, [map_current_y_offset]
    ;ld l, a
    ;ld a, [character_0_y]
    ;add l
    ;ld [character_0_y], a
    ;pop hl

    ; Load map logic
.load_logic:

    ; Bring remaining game objects to screen
    call goc_bring_all_other_game_objects_to_screen

    ; load logic layer
    call map_load_logic_layer

    ret

; Load Map Logic Layer
; arguments: ram_general_use_variable_5/6: LUT initial address
;            ram_general_use_variable_15/16: Initial X/Y
map_load_logic_layer:
    ; Load LUT initial address
    ld a, [ram_general_use_variable_5]
    ld l, a
    ld a, [ram_general_use_variable_6]
    ld h, a

    ; calculate map width x height
    call map_width_times_height
    ld a, [ram_general_use_variable_10]
    ld e, a
    ld a, [ram_general_use_variable_11]
    ld d, a

    ; add offset
    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a

    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a
    
    ; add to bc the first address based on initial X/Y
    push hl
    push de

    ; add initial address of map_logic to bc
    ld de, map_logic
    ld a, c
    add e
    ld c, a
    ld a, b
    adc d
    ld b, a

    pop de
    pop hl

    ld a, [map_current_height]
    ld d, a
.outer_loop:
    ld a, [map_current_width]
    ld e, a
.inner_loop:
    ld a, [hl]
    ld [bc], a
    inc hl
    inc bc
    dec e
    ld a, e
    cp $00
    jr nz, .inner_loop
        ; move to the next line in the logic map
        ; subtract screen width and add map width
        push de
        ld a, [map_current_width]
        ld e, a
        ld a, c
        sub e
        ld c, a
        ld a, b
        sbc $00
        ld b, a
        pop de

        ; add logic map width
        ld a, map_max_width
        add c
        ld c, a
        ld a, b
        adc $00
        ld b, a

        dec d
        jr nz, .outer_loop
    ret

; Set Character 0's initial screen offset, based on the current map offset.
; no arguments
; no returns
map_adjust_character_offset:
    ; set character offset to match the screen's initial X position.
    ld a, [map_current_x_offset]
    ld [character_0_offset_x], a

    ; set character offset to match the screen's initial Y position.
    ld a, [map_current_y_offset]
    ld [character_0_offset_y], a
    ret

; Calculate the total tiles based on the map width x height
; stores the values at ram_general_use_variable_11/ram_general_use_variable_10
map_width_times_height:
    push de
    push hl
    ld a, [map_current_width]
    ld e, a
    ld d, $00

    ld a, [map_current_height]
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; save value into ram_general_use_variable_10/11
    ld a, e
    ld [ram_general_use_variable_10], a
    ld a, d
    ld [ram_general_use_variable_11], a
    pop hl
    pop de
    ret

; Calculate dimensions of max-sized map
; stores the values at ram_general_use_variable_11/ram_general_use_variable_10
map_max_width_times_height:
    push de
    push hl
    ld a, map_max_width
    ld e, a
    ld d, $00

    ld a, map_max_height
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; save value into ram_general_use_variable_10/11
    ld a, e
    ld [ram_general_use_variable_10], a
    ld a, d
    ld [ram_general_use_variable_11], a
    pop hl
    pop de
    ret


; Calculate the total tiles based on the map SCREE_width x SCREEN_height
; Screen width is hardcoded to 20 and screen height is hardcoded to 18
map_screen_width_times_screen_height:
    push de
    push hl
    ld a, map_screen_width
    ld e, a
    ld d, $00

    ld a, map_screen_height
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; save value into ram_general_use_variable_10/11
    ld a, e
    ld [ram_general_use_variable_10], a
    ld a, d
    ld [ram_general_use_variable_11], a
    pop hl
    pop de
    ret

; Adjust final map Y position to match the map scoll position. 
map_adjust_final_map_y:
    push hl
    ld l, map_load_above
    call check_animation_direction
    jr nz, .return
        ; ADD THE CODE HERE
        ld a, map_screen_height
        ld h, a
        ld a, [map_current_y]
        ld l, a
.decrement:
        dec l
        ld a, l
        cp $FF
        jr nz, .skip_correction
            ld l, 31
.skip_correction:
        dec h
        ld a, h
        cp $00
        jr nz, .decrement
        ld a, l
        ld [ram_general_use_variable_12], a 
.return:
    pop hl
    ret

; Adjust final map X position to match the map scoll position. 
map_adjust_final_map_x:
    push hl
    ld l, map_load_left
    call check_animation_direction
    jr nz, .return
        ; ADD THE CODE HERE
        ld a, map_screen_width
        ld h, a
        ld a, [map_current_x]
        ld l, a
.decrement:
        dec l
        ld a, l
        cp $FF
        jr nz, .skip_correction
            ld l, 31
.skip_correction:
        dec h
        ld a, h
        cp $00
        jr nz, .decrement
        ld a, l
        ld [ram_general_use_variable_12], a 
.return:
    pop hl
    ret

; Used an offset in DE to locate tiles and attribute in the room's LUT's and load into VRAM
; de: Offset within the LUT
; hl: current tile LUT address
map_load_tile_and_attribute_vertical:
    ; Calculate VRAM address (base on the first row)
    push de
    push bc
    push hl
    ; A holds the current row to be rendered
    ld a, [ram_general_use_variable_7]
    ld de, 32
    ld l, a
    ld h, $00
    ; multiply A by the row width (in VRAM = 32)
    call mul_DE_HL_BCDEu
    pop hl
    ; result in DE is the fits element in the target row. Add it to ram_general_use_variable_9 (counter in the inner loop)
    ld a, [map_current_x]
    ld c, a

    ; only decrement a if the map is not being loaded in the origin
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jr z, .skip_decrement
        ld a, [ram_general_use_variable_9]
        dec a
        jr .continue_calculation

.skip_decrement:
    ld a, [ram_general_use_variable_9]

.continue_calculation:
    add c
    cp 32
    jr c, .no_correction
        sub a, 32
.no_correction
    add e
    ld e, a
    ld a, d
    adc $00
    ld d, a

    ld bc, _SCRN0
    ld a, e
    add c
    ld e, a
    ld a, d
    adc b
    ld d, a
    ; from this point onwards DE holds an address in VRAM (base _SCRN0)
    ; prepare to write to VRAM
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 0
    ld [rVBK], a
    ld a, [hl]
    ; add tile offset to hl
    ld c, a
    ld a, [ram_general_use_variable_4]
    add c
    call bgc_wait_for_VRAM
    ld [de], a

    ; load palette address
    ; add the number of tiles to hl to get the attribute tile
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 1
    ld [rVBK], a

    ; add offset to hl
    push hl
    ld a, [ram_general_use_variable_10]
    add a, l
    ld l, a
    ld a, [ram_general_use_variable_11]
    adc a, h
    ld h, a
    ld a, [hl]
    pop hl
    
    call bgc_wait_for_VRAM
    ld [de], a
    pop bc
    pop de
    
    ret

; Used an offset in DE to locate tiles and attribute in the room's LUT's and load into VRAM
; ram_general_use_variable_9: holds current row to be rendered
; de: Offset within the LUT
; hl: current tile LUT address
map_load_tile_and_attribute_horizontal:
    ; Calculate VRAM address (base on the first column)
    push de
    push bc
    push hl
    ; expression (Row *32 + column)
    ; A holds the current row to be rendered
    ld a, [ram_general_use_variable_9]
    ; The code was developed based on a single decrement of a (originally I planned to have the map offset subtracted from a)
    dec a
    ld e, a
    ; Add inital map Y and compensate for wrap around
    ld a, [map_current_y]
    add a, e
    cp 32
    jr c, .no_correction
        sub a, 32

.no_correction:
    ld de, 32
    ld l, a
    ld h, $00
    ; multiply A by the row width (in VRAM = 32)
    call mul_DE_HL_BCDEu
    pop hl
    ; result in DE is the fits element in the target row. Add it to ram_general_use_variable_9 (counter in the inner loop)
    ld a, [ram_general_use_variable_7]
    add e
    ld e, a
    ld a, d
    adc $00
    ld d, a

    ld bc, _SCRN0
    ld a, e
    add c
    ld e, a
    ld a, d
    adc b
    ld d, a
    ; from this point onwards DE holds an address in VRAM (base _SCRN0)
    ; prepare to write to VRAM
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 0
    ld [rVBK], a
    ld a, [hl]
    ; add tile offset to hl
    ld c, a
    ld a, [ram_general_use_variable_4]
    add c
    call bgc_wait_for_VRAM
    ld [de], a

    ; load palette address
    ; add the number of tiles to hl to get the attribute tile
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 1
    ld [rVBK], a
    
    ; add offset to hl
    push hl
    ld a, [ram_general_use_variable_10]
    add a, l
    ld l, a
    ld a, [ram_general_use_variable_11]
    adc a, h
    ld h, a
    ld a, [hl]
    pop hl
    
    call bgc_wait_for_VRAM
    ld [de], a
    pop bc
    pop de
    ret 

; checks in [ram_general_use_variable_7] whether wrap around happened and corrects it
; return: the variable (ram_general_use_variable_7) is adjusted automatically
map_wrap_around_detector:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .is_next_row_is_below
        push hl
        ld a, [ram_general_use_variable_7]
        ld l, a
        ld a, $FF
        cp l
        pop hl
        jr nz, .no_wrap_around
            ld a, 31
            ld [ram_general_use_variable_7], a
            ret
.is_next_row_is_below:
    push hl
    ld a, [ram_general_use_variable_7]
    ld l, a
    ld a, 31
    cp l
    pop hl
    jr nc, .no_wrap_around
        ld a, 0
        ld [ram_general_use_variable_7], a

.no_wrap_around
    ret

; checks in [ram_general_use_variable_7] whether wrap around happened and corrects it
; return: the variable (ram_general_use_variable_7) is adjusted automatically
map_wrap_around_detector_horizontal:
    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .is_next_column_is_right
        push hl
        ld a, [ram_general_use_variable_7]
        ld l, a
        ; This fucntion considers that negative additions to the column initial rendering will be made in steps of 1.
        ; This is not correct, since based on the map intital offset up to -16 can be addded to an initial position of 0
        ; fix it.
        ld a, $FF
        cp l
        pop hl
        jr nz, .no_wrap_around
            ld a, 31
            ld [ram_general_use_variable_7], a
            ret
.is_next_column_is_right:
    push hl
    ld a, [ram_general_use_variable_7]
    ld l, a
    ld a, 31
    cp l
    pop hl
    jr nc, .no_wrap_around
        ld a, 0
        ld [ram_general_use_variable_7], a

.no_wrap_around
    ret

; based on the map horizontal position, calculate the first LUT address
; hl: holds the initial address of the tile LUT
; return (hl): adjusted address based on the map load direction
map_calculate_first_address_in_LUT_horizontal:
    ; check animation direction
    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .is_movement_to_the_right
        ; Upwards
        ; the first tile in the LUT is the first column in the last row
        ; expression: HL + ((MAP WIDTH)  - 1)
        ; calculate map dimensions
        push de
        push hl
        ld a, [map_current_width]
        ld e, a
        ld d, $00
        ; MAP WIDTH - 1
        dec de

        ld a, [map_current_height]
        ld l, a
        ld h, $00

        push de
        ; only DE will be used
        call mul_DE_HL_BCDEu
        ld c, e
        ld b, d
        pop hl
        pop de

        ; DE holds the offset to the first tile in the LUT. To get the real address, add it to the recovered hl
        ld a, l
        add e
        ld l, a
        ld a, h
        adc d
        ld h, a
        pop de
        jr .end_condition

    ; Downwards
.is_movement_to_the_right:    
    ; nothing to do. First tile in LUT is always the first one
.end_condition:
    ret


; based on the map vertical position, calculate the first LUT address
; hl: holds the initial address of the tile LUT
; return (hl): adjusted address based on the map load direction
map_calculate_first_address_in_LUT_vertical:
    ; check animation direction
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    cp a, $01
    jr nz, .check_the_directions
        ; Nothing to do
        jr .end_condition

.check_the_directions:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .is_movement_downwards

        ; Upwards
        ; the first tile in the LUT is the first column in the last row
        ; expression: HL + ((MAP WIDTH) * (MAP HEIGHT - 1))
        ; calculate map dimensions
        push de
        push hl
        ld a, [map_current_height]
        ld e, a
        ld d, $00
        ; MAP HEIGHT - 1
        dec de

        ld a, [map_current_width]
        ld l, a
        ld h, $00

        ; only DE will be used
        call mul_DE_HL_BCDEu
        ld c, e
        ld b, d
        pop hl

        ; DE hodls the offset to the first tile in the LUT. To get the real address, add it to the recovered hl
        ld a, l
        add e
        ld l, a
        ld a, h
        adc d
        ld h, a
        pop de
        jr .end_condition

    ; Downwards
.is_movement_downwards:    
    ; nothing to do. First tile in LUT is always the first one
.end_condition:
    ret

; Determines first column, based on the direction
; return (a): first columnt to be rendered
map_calculate_first_tile_column:

    ; Check animation direction
    ld l, map_load_left
    call check_animation_direction
    jr nz, .is_movement_right
        ; if movement is to the left, the next column will be the one right before the first column of the currently loaded map.
        ; Watch for wrap around (if current column is 0, it must return to the last column.)
        ld a, [map_current_x]
        dec a
        cp $FF
        jr nz, .no_wrap_around_to_31
            ld a, 31
.no_wrap_around_to_31:
        jr .end_condition

.is_movement_right:
    ; If the movement is to the right, the next column will be the one right after the last column of the currently loaded map
    ; expression (MAP X + MAP WIDTH) + 1. Watch for wrap around (if result == 32, the next column is 0)
    ld a, map_screen_width
    ld l, a
    ld a, [map_current_x]
    add l
    ld l, a
    ld a, 31
    cp l
    jr nc, .no_wrap_around_to_0
        ld a, l
        ld l, 32
        sub l
        jr .end_condition
.no_wrap_around_to_0:
            ld a, l
    
.end_condition:
    ret

; Determines first row, based on the direction
; return (a): first row to be rendered
map_calculate_first_tile_row:

    ; check animation direction
    ld l, map_load_origin
    call check_animation_direction
    cp a, $01
    jr nz, .check_the_directions
        ld a, $00
        jr .end_condition

.check_the_directions:
    ld l, map_load_above
    call check_animation_direction
    jr nz, .is_movement_downwards
        ; Upwards
        ; From bottom to top, the first row will alwaus be the first one right above the current map position
        ; if it is equal to $FF (-1) wrap around to 31
        ld a, [map_current_y]
        dec a
        cp $FF
        jr nz, .no_wrap_around_to_31
            ld a, 31
.no_wrap_around_to_31:
        jr .end_condition

    ; Downwards
.is_movement_downwards:
    ; From top to bottom, the first row will always be the same as the one requested to be the first of the room
    ; The first row will always be the row right after the last row of the currently loaded map
    ; first_row = (MAP Y + MAP HEIGHT) -> if >= 32 then wrap around to 0 + 32 - (MAP Y + MAP HEIGHT)
    ld a, map_screen_height
    ld l, a
    ld a, [map_current_y]
    add l
    ld l, a
    ld a, 31
    cp l
    jr nc, .no_wrap_around_to_0
        ld a, l
        ld l, 32
        sub l
        jr .end_condition
.no_wrap_around_to_0:
            ld a, l
    
.end_condition:
    ret

; Scroll maps (one tile) vertically, in the direction held by a
; a: scrolling direction: 0 -> downwards 1 -> upwards
map_scroll_bg_vertically_with_animation:
    ld c, 2
    ld b, a
.one_more:
    ld hl, background_scrolling_request_Y
    ld a, b
    cp $00
    jr nz, .scroll_up

    push hl
    push de
    push bc
    ld c, -2
    ld b, -4
    call map_move_player_character_vertically
    ld d, -4
    ld e, $00
    ld b, $01 ; a indicate that the scrolling is for screen transitions, so game objects will be unloaded
    call goc_scroll_game_objects_excluding_player
    call display_wait_vblank
    call _HRAM
    pop bc
    pop de
    pop hl

    ld a, [hl]
    add a, 4
    jr .scroll_complete

.scroll_up:

    push hl
    push de
    push bc
    ld c, 4
    ld b, 2
    call map_move_player_character_vertically
    ld d, 4
    ld e, $00
    ld b, $01 ; a indicate that the scrolling is for screen transitions, so game objects will be unloaded
    call goc_scroll_game_objects_excluding_player
    call display_wait_vblank
    call _HRAM
    pop bc
    pop de
    pop hl

    ld a, [hl]
    add a, -4

.scroll_complete:
    ld [background_scrolling_request_Y], a
    dec c
    ; Directly call this function to update the background (otherwise it will only be called in the main loop, but map loading is blocking).
    call bgc_safely_update_background
    ld a, c
    cp $00
    jr nz, .one_more
    ret

; Adjust character horizontal position as the screen moves
; c: small increment
; b: large increment
map_move_player_character_horizontally:
    push hl
    ld l, map_load_right
    call check_animation_direction
    pop hl
    jr nz, .movement_left
        ld e, c
        ld a, [ram_general_use_variable_8]
        cp $0F
        jr nc, .update_position
        ld e, b
        jr .update_position
.movement_left:
    ld e, c
    ld a, [ram_general_use_variable_8]
    cp $0F
    jr nc, .update_position
    ld e, b
.update_position:
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    inc hl 
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    ret

; Adjust character vertical position as the screen moves
; c: small increment
; b: large increment
map_move_player_character_vertically:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .movement_down
        ld e, c
        ld a, [ram_general_use_variable_8]
        cp $0F
        jr c, .update_position
        ld e, b
        jr .update_position
.movement_down:
    ld e, c
    ld a, [ram_general_use_variable_8]
    cp $0F
    jr nc, .update_position
    ld e, b
.update_position:
    ld a, [ram_player_character_id]
    call goc_get_gameobject_address
    ld a, [hl]
    add a, e
    ld [hl], a
    inc hl 
    inc hl
    inc hl
    inc hl
    ld a, [hl]
    add a, e
    ld [hl], a
    ret

; Scroll maps (one tile) horizontal, in the direction held by a
; a: scrolling direction: 0 -> right 1 -> left
map_scroll_bg_horizontally_with_animation:
    ld c, 2
    ld b, a
.one_more:
    ld hl, background_scrolling_request_X
    ld a, b
    cp $00
    jr nz, .scroll_right

    push hl
    push de
    push bc
    ld c, -3
    ld b, -4
    call map_move_player_character_horizontally
    ld d, $00
    ld e, -4
    ld b, $01 ; a indicate that the scrolling is for screen transitions, so game objects will be unloaded
    call goc_scroll_game_objects_excluding_player
    call display_wait_vblank
    call _HRAM
    pop bc
    pop de
    pop hl
    
    ld a, [hl]
    add a, 4
    jr .scroll_complete

.scroll_right:
    push hl
    push de
    push bc
    ld c, 3
    ld b, 4
    call map_move_player_character_horizontally
    ld d, $00
    ld e, 4
    ld b, $01 ; a indicate that the scrolling is for screen transitions, so game objects will be unloaded
    call goc_scroll_game_objects_excluding_player
    call display_wait_vblank
    call _HRAM
    pop bc
    pop de
    pop hl

    ld a, [hl]
    add a, -4

.scroll_complete:
    ld [background_scrolling_request_X], a
    dec c
    ; Directly call this function to update the background (otherwise it will only be called in the main loop, but map loading is blocking).
    call bgc_safely_update_background
    ld a, c
    cp $00
    jr nz, .one_more
    ret

; Set background scrolling position to map_current_y * 8
map_scroll_bg_to_target_position_without_animation:
    ld a, [map_current_y]
    sla a
    sla a
    sla a
    ld [background_scrolling_request_Y], a
    ret

; checks whether current scroll direction is the one matching in l
; This function assumes the settings are loaded in ram_general_use_variable_1
; l: scroll direction
; return (a): 1 true, 0 false
check_animation_direction:
    ld a, [ram_general_use_variable_1]
    ; get the animation bits (for l and a)
    srl a
    srl a
    
    srl l
    srl l

    and $07
    cp l
    jr nz, .does_not_match
    ld a, $01
    ret
.does_not_match:
    ld a, $00
    ret

; Converts value from pixels to tiles
; a: target value
; return (a): picel value converted to tiles
map_convert_pixels_to_tiles;
    srl a
    srl a
    srl a
    ret

; Scroll Map Horizontally. The player position used is the raw value in OAMRAM
; a: scroll direction (1, left; 0 right)
; return: a -> 1: scrolled 0: did not scroll
map_scroll_map_horizontally_if_needed:    
    cp $00
    jr nz, .scroll_left

        push hl
.wait
        ;call bgc_wait_for_VRAM
        push hl
        call ram_get_player_game_obj_address
        inc hl
        ld a, [hl]
        pop hl
        
        ; sometimes the result will be $FF (try again until it is correct)
        cp $FF 
        jr z, .wait
        inc a
        ld l, a
        ld a, $50
        cp l
        pop hl
        jr nc, .finish_not_scrolled

        ; Check offset position (do not scroll if Offset + Screen Height == map Height)
        push hl
        ld a, [map_current_x_offset]
        add map_screen_width*8
        ld l, a
        ld a, [map_current_width]
        sla a
        sla a
        sla a
        cp l
        pop hl
        jr z, .finish_not_scrolled
            ld a, [background_scrolling_request_X]
            inc a
            ld [background_scrolling_request_X], a

            ; scroll game objects
            ld d, $00
            ld e, -1
            ld b, $00 ; a indicate that the srolling is not for screen transitions, so game objects will not be unloaded
            call goc_scroll_game_objects_excluding_player

            ld a, [map_current_x_offset]
            inc a
            ld [map_current_x_offset], a
                
            ld a, [character_0_offset_x]
            add a, 1
            ld [character_0_offset_x], a
            jr .finish

.scroll_left:
    push hl
.wait_2
    ;call bgc_wait_for_VRAM
    push hl
    call ram_get_player_game_obj_address
    inc hl
    ld a, [hl]
    pop hl
    ; sometimes the result will be $FF (try again until it is correct)
    cp $FF 
    jr z, .wait_2
    inc a
    ld l, a
    ld a, $51
    cp l
    pop hl
    jr c, .finish_not_scrolled

    ; Check offset position (do not scroll if 0)
    ld a, [map_current_x_offset]
    cp $00
    jr z, .finish_not_scrolled
        ld a, [background_scrolling_request_X]
        dec a
        ld [background_scrolling_request_X], a

        ; scroll game objects
        ld d, $00
        ld e, 1
        ld b, $00 ; a indicate that the scrolling is for screen transitions, so game objects will be unloaded
        call goc_scroll_game_objects_excluding_player

        ld a, [map_current_x_offset]
        dec a
        ld [map_current_x_offset], a

        ld a, [character_0_offset_x]
        sub a, 1
        ld [character_0_offset_x], a
        jr .finish

.finish_not_scrolled:
    ld a, $00
    ret 
    
.finish
    ld a, $01
    ret


; Scroll Map Vertically
; a: scroll direction (1, up ; 0 down)
; return: a -> 1: scrolled 0: did not scroll
map_scroll_map_vertically_if_needed:
    cp $00
    jr nz, .scroll_down

    push hl
.wait
    ;call bgc_wait_for_VRAM
    push hl
    call ram_get_player_game_obj_address
    ld a, [hl]
    pop hl
    cp $FF
    jr z, .wait
    inc a
    ld l, a
    ld a, $58
    cp l
    pop hl
    jr nc, .finish_not_scrolled

    ; Check offset position (do not scroll if Offset + Screen Height == map Height)
    push hl
    ld a, [map_current_y_offset]
    add map_screen_height*8
    ld l, a
    ld a, [map_current_height]
    sla a
    sla a
    sla a
    cp l
    pop hl
    jr z, .finish_not_scrolled
            ld a, [background_scrolling_request_Y]
            inc a
            ld [background_scrolling_request_Y], a

            ; scroll game objects
            ld d, -1
            ld e, $00
            ld b, $00 ; a indicate that the srolling is not for screen transitions, so game objects will not be unloaded
            call goc_scroll_game_objects_excluding_player

            ld a, [map_current_y_offset]
            inc a
            ld [map_current_y_offset], a
.skip_up_increment:
            ld a, [character_0_offset_y]
            add a, 1
            ld [character_0_offset_y], a
            ld a, $01
            ret

.scroll_down:
    push hl
.wait_2
    ;call bgc_wait_for_VRAM
    push hl
    call ram_get_player_game_obj_address
    ld a, [hl]
    pop hl
    cp $FF
    jr z, .wait_2
    inc a
    ld l, a
    ld a, $59
    cp l
    pop hl
    jr c, .finish_not_scrolled

    ; Check offset position (do not scroll if 0)
    ld a, [map_current_y_offset]
    cp $00
    jr z, .finish_not_scrolled
        ld a, [background_scrolling_request_Y]
        dec a
        ld [background_scrolling_request_Y], a

        ; scroll game objects
        ld d, 1
        ld e, $00
        ld b, $00 ; a indicate that the srolling is not for screen transitions, so game objects will not be unloaded
        call goc_scroll_game_objects_excluding_player

        ld a, [map_current_y_offset]
        dec a
        ld [map_current_y_offset], a
.skip_down_increment:
        ld a, [character_0_offset_y]
        sub a, 1
        ld [character_0_offset_y], a
        jr .finish

.finish_not_scrolled:
    ld a, $00
    ret

.finish:
    ld a, $01
    ret 

; Convert map position in pixels into map tiles
; a: position in pixels
; return: position in tiles
map_pixel_to_tile:
    srl a
    srl a
    srl a
    ret

map_request_map_load:
    ld a, 1
    ld [map_load_request_flag], a
    ret

map_commit_map_load_request:
    ld a, [map_load_request_flag]
    cp $01
    ret nz

    ; initialize game object callback
    ld a, [map_game_object_initializer_address_LSB]
    ld l, a
    ld a, [map_game_object_initializer_address_MSB]
    ld h, a
    call bac_set_gob_initializer

    ; process object callback
    ld a, [map_process_callback_address_LSB]
    ld l, a
    ld a, [map_process_callback_address_MSB]
    ld h, a
    call bac_set_process_callback

    ; process init callback
    ld a, [map_process_callback_address_LSB]
    ld l, a
    ld a, [map_process_callback_address_MSB]
    ld h, a
    call bac_set_init_callback

    ; process init callback
    ld a, [map_bank_ID_LSB]
    ld e, a
    ld a, [map_bank_ID_MSB]
    ld d, a
    call bac_set_bank_switching_intention

    ; clear request flag
    ld a, $00
    ld [map_load_request_flag], a

    ; Switch to target bank
    call bac_switch_bank

    ; load map
    ld a, [map_room_data_address_LSB]
    ld l, a
    ld a, [map_room_data_address_MSB]
    ld h, a
    ld a, [map_room_tiles_address_LSB]
    ld c, a
    ld a, [map_room_tiles_address_MSB]
    ld b, a
    ld a, [map_room_Y]
    ld e, a
    ld a, [map_room_X]
    ld d, a
    ld a, [map_loading_settings_flags]
    call map_load_room
        
    ; restore target bank
    call bac_restore_bank

    ; clear collision values (required before initializing)
    call chr_clear_collision
    ret
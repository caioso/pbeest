; Project Beest
; Map Controller
; Developed by Caio Souza Oliveira
; 19 Aug 2019

; ROOM Attributes
; inform that a new batch of palettes will be loaded VRAM 
map_load_palettes equ $01
; inform that a new batch of tiles will be loaded VRAM 
map_load_tiles equ $02

; in Map transition animation
map_load_origin equ $00
map_load_above equ $04
map_load_below equ $08
map_load_left equ $0C
map_load_right equ $10

; base tile memory base section address
map_tile_base_section_8000 equ 0
map_tile_base_section_9000 equ $20

map_initialize_map_controller:
    ld a, $00
    ld [map_current_x], a;
    ld [map_current_y], a;
    ld a, map_screen_width
    ld [map_current_width], a
    ld a, map_screen_height
    ld [map_current_height], a
    ret

; Loads Room data (tiles, palletes and logic) at a specific position in the video buffer (video buffer size 32x32). With or without animations.
; hl: Room initial address
; a: animation & Data Loading Bit Map
;    bit 0: load palettes
;    bit 1: load tiles
;    bit [2:5]
;      0x00: No Animation
;      0x01: Left-to-Right
;      0x02: Right-to-Left
;      0x03: top-to-bottom
;      0x04: bottom-to-top
;    bit 6: base tile bank
; bc: initial tile address (full 16 bits tile address)
; de: map initial position X(d) and Y(e) [in tiles, not pixels]
map_load_room:
    ; save temp variables 
    ; save map data loading attributes bit map
    push hl
    ld hl, ram_general_use_variable_1
    ld [hl], a
    ld hl, ram_general_use_variable_2
    ld [hl], c
    ld hl, ram_general_use_variable_3
    ld [hl], b
    ld hl, ram_general_use_variable_15
    ld [hl], d
    ld hl, map_current_x_offset
    sla d
    sla d
    sla d
    ld [hl], d
    ld hl, ram_general_use_variable_16
    ld [hl], e
    ld hl, map_current_y_offset
    sla e
    sla e
    sla e
    ld [hl], e
    pop hl

    ; Load room metadata (save old map position)
    ; load map position X(d), Y(e)
    ; save original position
    push hl

    ; calculate tile map offset (based on initial address in VRAM)
    ; This is added to the room's tile LUT to find the correct tile ID for each entry in the room
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    bit 5, a
    jr z, .base_8000
        ld hl, $9000
        jr .continue_offset_tile_id_calculation
.base_8000:
        ld hl, $8000
.continue_offset_tile_id_calculation:
        ld a, c
        sub l
        ld e, a
        ld a, b
        sbc h
        ld d, a
        
        ;divide by 16 to get the correct tile offset (DE/BC)
        ld c, $10
        ld b, $00
        call div_DE_BC_DEBCu
        ; only the first byte of the division results matter (e)
        ld hl, ram_general_use_variable_4
        ld [hl], e

    pop hl

    ; hl holds the address of the room width byte
    ld de, map_current_width
    ld a, [hl]
    ld [de], a

    ; hl + 1 holds the address of the room height byte
    inc hl 
    ld de, map_current_height
    ld a, [hl]
    ld [de], a

    ; calculate total number of tiles at ram_general_use_variable_11/ram_general_use_variable_12
    call map_screen_width_times_screen_height

    ; load palette target bank (nothing to do for now)
    inc hl
    
    ; Palette loading routine
    ; step 1: check whether the palettes are meant to be loaded
    inc hl
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_palettes
    jr z, .skip_palette_load
        ; step 2: load tiles
        ; load initial palette address
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load total palettes
        inc hl
        ld a, [hl]
        
        ; room palettes (0-6) always start at 0
        ld bc, $00

        ; move de to hl (required as function argument)
        push hl
        ld l, e
        ld h, d

        ; move a to de
        ld e, a
        ld d, $00

        ; load palettes
        call bgc_load_background_palette
        pop hl
        jr .palette_loaded_skipped

.skip_palette_load:
    inc hl
    inc hl
.palette_loaded_skipped:
    ; load background tiles (not actual LUT but tile-patterns in VRAM)
    ; load palette target bank (nothing to do for now)
    inc hl

    ; Tile loading routine
    ; Check whether tiles should be loaded into VRAM and at which initial offset
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_tiles
    jr z, .skip_tiles_load
        ; load background tiles initial address
        inc hl
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load number of tiles
        inc hl
        ld a, [hl]
        ld c, a
        inc hl
        ld a, [hl]
        ld b, a

        ; move de to hl
        push hl
        ld l, e
        ld h, d
        
        ; configure rVBK to load tiles (a = 0)
        ld a, $00

        ; load initial tiles address
        push hl
        ld hl, ram_general_use_variable_2
        ld e, [hl]
        ld hl, ram_general_use_variable_3
        ld d, [hl]
        pop hl
        ; load tile initial address in 
        call tilecrt_load_tiles

        pop hl
        jr .tile_loaded_skipped

.skip_tiles_load:
    inc hl
    inc hl
    inc hl
    inc hl
.tile_loaded_skipped:
    ; is this one really needed? V
    inc hl

    ; save tile LUT initial address ram_general_use_variable_5, ram_general_use_variable_6
    ld a, l
    ld [map_current_LUT_address_byte_1], a
    ld [ram_general_use_variable_5], a
    ld a, h
    ld [map_current_LUT_address_byte_2], a
    ld [ram_general_use_variable_6], a

    ; Check the scrolling direction
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jp z, .vertical_scrolling
    ; Horizontal scrolling
    ; calculate first tile column 
    push hl
    call map_calculate_first_column
    pop hl
    ; save first column to RAM (ram_general_use_variable_7)
    ld [ram_general_use_variable_7], a
    ; [ram_general_use_variable_12] holds the final X value to be stored in map_current_x
    ld [ram_general_use_variable_12], a
    ; only required for upwards movement. Adjust 12 in case of wraparound
    call map_adjust_final_map_x

    ; calculate first tile address in LUT
    call map_calculate_first_address_in_LUT_horizontal 
    ; save first address to be used later
    ld a, l
    ld [ram_general_use_variable_13], a
    ld a, h
    ld [ram_general_use_variable_14], a

    ; from this point onwards, HL holds the address of the first tile to be loaded

    ; prepare loop
    ; ram_general_use_variable_8: holds outer counter (width)
    ; ram_general_use_variable_9: holds inner counter (height)
    ; outer counter
    ld a, $00
    ld [ram_general_use_variable_8], a

    ; Recalculate room real dimensions
    call map_width_times_height

.tile_loading_outer_loop_horizontal:
    ld a, $00
    ld [ram_general_use_variable_9], a

.tile_loading_inner_loop_horizontal:

    ; calculate address offset within the LUT
    push de
    ld a,[ram_general_use_variable_5]
    ld e, a
    ld a,[ram_general_use_variable_6]
    ld d, a

    ; subtract HL from DE (DE holds the initial address of the LUT) in order to get only offsets
    ld a, l
    sub e
    ld e, a
    ld a, h
    sbc d
    ld d, a

    ; DE Holds the Offset within the LUT. Use it to find the position in both VRAM banks
    call map_load_tile_and_attribute_horizontal
    pop de

    ; add current width to HL
    ld a, [map_current_width]
    add l
    ld l, a
    ld a, h
    adc $00
    ld h, a

    ; inner loop boundary check
    ld a, [ram_general_use_variable_9]
    inc a
    ld [ram_general_use_variable_9], a
    push hl
    ld l, a
    
    ; height is guaranteed to be 18 tiles
    ; *NEW* Load the entire room at once
    ;ld a, map_screen_height
    ld a, [map_current_height]
    cp l
    pop hl
    jr nz, .tile_loading_inner_loop_horizontal

.complete_loading_column:
    ; outer loop boundary check
    ld a, [ram_general_use_variable_8]
    inc a
    ld [ram_general_use_variable_8], a
    push hl
    ld l, a

    ; Map width is guaranteed to be 20 tiles
    ; *NEW* load the entire room at once
    ;ld a, map_screen_width
    ld a, [map_current_width]
    cp l
    pop hl
    jr z, .complete_map_loading_horizontal
        ; prepare for the next iteration of the outer loop
        ; update column for the next iterations of the internal loop
        push hl
        ld l, map_load_left
        call check_animation_direction
        pop hl
        jr nz, .is_next_column_is_right
            ; Show appropriate scroll animation (left)
            push hl
            push bc
            ; check whether the amount of screen columns have been scrolled
            ld a, [ram_general_use_variable_8]
            sub map_screen_width
            jr nc, .skip_camera_movement_left
                ld a, 1
                call map_scroll_bg_horizontally_with_animation

.skip_camera_movement_left:
            pop bc
            pop hl
            jr .horizontal_animation_complete

.is_next_column_is_right:
            push hl
            push bc

            ld a, [ram_general_use_variable_8]
            sub map_screen_width
            jr nc, .skip_camera_movement_right
                ld a, 0
                call map_scroll_bg_horizontally_with_animation

.skip_camera_movement_right:
            pop bc
            pop hl

.horizontal_animation_complete:
        push hl
        ld l, map_load_left
        call check_animation_direction
        pop hl
        ld a, [ram_general_use_variable_7]
        jr nz, .increment_column
            dec a
            ld [ram_general_use_variable_7], a

            ;hl should point to the first element of the previous column
            ld a, [ram_general_use_variable_13]
            ld l, a
            ld a, [ram_general_use_variable_14]
            ld h, a
            dec hl
            ld a, l
            ld [ram_general_use_variable_13], a
            ld a, h
            ld [ram_general_use_variable_14], a

            jr .save_column
.increment_column:
            inc a
            ld [ram_general_use_variable_7], a

            ; hl should point to the first element of the next column
            ld a, [ram_general_use_variable_13]
            ld l, a
            ld a, [ram_general_use_variable_14]
            ld h, a
            inc hl
            ld a, l
            ld [ram_general_use_variable_13], a
            ld a, h
            ld [ram_general_use_variable_14], a
.save_column:   
        ; correct ram_general_use_variable_7 in case of wrap around
        call map_wrap_around_detector_horizontal
        jp .tile_loading_outer_loop_horizontal

.complete_map_loading_horizontal:

    ; last horizontal scroll after the map is complete loading
    push hl
    ld l, map_load_right
    call check_animation_direction
    pop hl
    jr nz, .scroll_up_h
        ld a, 0
        jr .last_scroll_h
.scroll_up_h:
        ld a, 1
.last_scroll_h:
        push hl
        push bc
        call map_scroll_bg_horizontally_with_animation
        pop bc
        pop hl
    
    ; update map X
    ld a, [ram_general_use_variable_12]
    ld [map_current_x], a

    ; Adjust Player Character Position
    push hl
    ld l, map_load_right
    call check_animation_direction
    pop hl
    jr nz, .final_left_position
        ld a, $08
        jr .adjust_x_position
.final_left_position:
        ld a, $98
.adjust_x_position:
    ld [character_0_x], a

    ; load map logic layer
    call map_load_logic_layer
    ret

.vertical_scrolling:
    ; vertical scrolling
    ; calculate first tile row
    push hl
    call map_calculate_first_tile_row
    pop hl
    ; save first row to RAM (ram_general_use_variable_7)
    ld [ram_general_use_variable_7], a
    ; [ram_general_use_variable_12] holds the final Y value to be stored in map_current_y
    ld [ram_general_use_variable_12], a
    ; only required for upwards movement. Adjust 12 in case of wraparound
    call map_adjust_final_map_y

    ; calculate first tile address in LUT
    call map_calculate_first_address_in_LUT_vertical
    ; from this point onwards, HL holds the address of the first tile to be loaded

    ; prepare loop
    ; ram_general_use_variable_8: holds outer counter (height)
    ; ram_general_use_variable_9: holds inner counter (width)
    ; outer counter
    ld a, $00
    ld [ram_general_use_variable_8], a

    ; Calculate room's real dimensions
    call map_width_times_height

.tile_loading_outer_loop_vertical:
    ld a, $00
    ld [ram_general_use_variable_9], a

.tile_loading_inner_loop_vertical:
    ; calculate address offset within the LUT
    push de
    ld a,[ram_general_use_variable_5]
    ld e, a
    ld a,[ram_general_use_variable_6]
    ld d, a

    ; subtract HL from DE (DE holds the initial address of the LUT) in order to get only offsets
    ld a, l
    sub e
    ld e, a
    ld a, h
    sbc d
    ld d, a

    ; DE Holds the Offset within the LUT. Use it to find the position in both VRAM banks
    call map_load_tile_and_attribute_vertical
    pop de

    ; increment hl (move to the next element in the same row)
    inc hl

    ; inner loop boundary check
    ld a, [ram_general_use_variable_9]
    inc a
    ld [ram_general_use_variable_9], a
    push hl
    ld l, a

    ; Map width is guaranteed to be 20 tiles
    ld a, map_screen_width

    cp l
    pop hl
    jr nz, .tile_loading_inner_loop_vertical

.complete_loading_row:
    ; outer loop boundary check
    ld a, [ram_general_use_variable_8]
    inc a
    ld [ram_general_use_variable_8], a
    push hl
    ld l, a

    ; Map height is guaranteed to be 18 tiles
    ld a, map_screen_height
    cp l
    pop hl
    jr z, .complete_map_loading_vertical
        ; prepare for the next iteration of the outer loop
        ; update row for the next iterations of the internal loop
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        jr nz, .is_next_row_is_below
            ; Show appropriate scroll animation (UP)
            ld a, 1
            push hl
            push bc
            call map_scroll_bg_vertically_with_animation
            pop bc
            pop hl
            jr .skip_animation

.is_next_row_is_below:
        ; Show appropriate scroll animation (DOWN)
        push hl
        ld l, map_load_origin
        call check_animation_direction
        pop hl
        jr z, .skip_animation
            ld a, 0
            push hl
            push bc
            call map_scroll_bg_vertically_with_animation
            pop bc
            pop hl

.skip_animation:
        push hl
        ld l, map_load_above
        call check_animation_direction
        pop hl
        ld a, [ram_general_use_variable_7]
        jr nz, .increment_row
            dec a
            ld [ram_general_use_variable_7], a

             ; Subtract the room width and the screen width to get to the next row above teh current one
            push de
            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a

            ld a, map_screen_width
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a
            pop de

            jr .save_row
.increment_row:
            inc a
            ld [ram_general_use_variable_7], a

            push de
            ld a, [map_current_width]
            ld e, a
            
            ; subtract e from hl
            ld a, l
            add e
            ld l, a
            ld a, h
            adc $00
            ld h, a

            ld a, map_screen_width
            ld e, a
            
            ; subtract e from hl
            ld a, l
            sub e
            ld l, a
            ld a, h
            sbc $00
            ld h, a
            pop de
.save_row:   
        ; correct ram_general_use_variable_7 in case of wrap around
        call map_wrap_around_detector
        jp .tile_loading_outer_loop_vertical

.complete_map_loading_vertical:
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jr nz, .scroll_on_last_time
        call map_scroll_bg_to_target_position_without_animation
        jr .map_load_complete
        
.scroll_on_last_time:
    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jr nz, .scroll_up
        ld a, 0
        jr .last_scroll
.scroll_up:
        ld a, 1
.last_scroll:
        push hl
        push bc
        call map_scroll_bg_vertically_with_animation
        pop bc
        pop hl

.map_load_complete:
    ; update map Y
    ld a, [ram_general_use_variable_12]
    ld [map_current_y], a

    ; Adjust Player Character Position
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    jr z, .load_logic

    push hl
    ld l, map_load_below
    call check_animation_direction
    pop hl
    jr nz, .final_up_position
        ld a, $10
        jr .adjust_y_position
.final_up_position:
        ld a, $90
.adjust_y_position:
    ld [character_0_y], a

    ; Load map logic
.load_logic:
    call map_load_logic_layer
    ret

; Load Map Logic Layer
; arguments: ram_general_use_variable_5/6: LUT initial address
;            ram_general_use_variable15/16: intiial X/Y
map_load_logic_layer:
    ; Load LUT initial address
    ld a, [ram_general_use_variable_5]
    ld l, a
    ld a, [ram_general_use_variable_6]
    ld h, a

    ; calculate map width x height
    call map_width_times_height
    ld a, [ram_general_use_variable_10]
    ld e, a
    ld a, [ram_general_use_variable_11]
    ld d, a

    ; add offset
    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a

    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a

    ; From this point onwards, HL has the first address of the logic layer
    ; DE holds the amount of logic tiles to load

    ; Load initial address based on initial X and initial Y position
    push hl
    push de

    ; Expression HL + ((initial_y * map_width) + initial_x)
    ld a, [ram_general_use_variable_16]
    ld e, a
    ld d, $00

    ld a, [map_current_width]
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; copy de to bc
    ld c, e
    ld b, d

    ; Add width
    ld a, [ram_general_use_variable_15]
    add c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    pop de
    pop hl

    ld a, c
    add l
    ld l, a
    ld a, b
    adc h
    ld h, a

    ld bc, map_logic
    ld d, map_screen_height
.outer_loop:
    ld e, map_screen_width
.inner_loop:
    ld a, [hl]
    ld [bc], a
    inc hl
    inc bc
    dec e
    ld a, e
    cp $00
    jr nz, .inner_loop
        ; move to the next line in the logic map
        ; subtract screen width and add map width
        ld a, l
        sub map_screen_width
        ld l, a
        ld a, h
        sbc $00
        ld h, a

        ; add LUT width
        ld a, [map_current_width]
        add l
        ld l, a
        ld a, h
        adc $00
        ld h, a

        dec d
        jr nz, .outer_loop
    ret

; Calculate the total tiles based on the map width x height
; stores the values at ram_general_use_variable_11/ram_general_use_variable_10
map_width_times_height:
    push de
    push hl
    ld a, [map_current_width]
    ld e, a
    ld d, $00

    ld a, [map_current_height]
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; save value into ram_general_use_variable_10/11
    ld a, e
    ld [ram_general_use_variable_10], a
    ld a, d
    ld [ram_general_use_variable_11], a
    pop hl
    pop de
    ret

; Calculate the total tiles based on the map SCREE_width x SCREEN_height
; Screen width is hardcoded to 20 and screen height is hardcoded to 18
map_screen_width_times_screen_height:
    push de
    push hl
    ld a, map_screen_width
    ld e, a
    ld d, $00

    ld a, map_screen_height
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; save value into ram_general_use_variable_10/11
    ld a, e
    ld [ram_general_use_variable_10], a
    ld a, d
    ld [ram_general_use_variable_11], a
    pop hl
    pop de
    ret

; Adjust final map Y position to match the map scoll position. 
map_adjust_final_map_y:
    push hl
    ld l, map_load_above
    call check_animation_direction
    jr nz, .return
        ; ADD THE CODE HERE
        ld a, map_screen_height
        ld h, a
        ld a, [map_current_y]
        ld l, a
.decrement:
        dec l
        ld a, l
        cp $FF
        jr nz, .skip_correction
            ld l, 31
.skip_correction:
        dec h
        ld a, h
        cp $00
        jr nz, .decrement
        ld a, l
        ld [ram_general_use_variable_12], a 
.return:
    pop hl
    ret

; Adjust final map X position to match the map scoll position. 
map_adjust_final_map_x:
    push hl
    ld l, map_load_left
    call check_animation_direction
    jr nz, .return
        ; ADD THE CODE HERE
        ld a, map_screen_width
        ld h, a
        ld a, [map_current_x]
        ld l, a
.decrement:
        dec l
        ld a, l
        cp $FF
        jr nz, .skip_correction
            ld l, 31
.skip_correction:
        dec h
        ld a, h
        cp $00
        jr nz, .decrement
        ld a, l
        ld [ram_general_use_variable_12], a 
.return:
    pop hl
    ret

; Used an offset in DE to locate tiles and attribute in the room's LUT's and load into VRAM
; de: Offset within the LUT
; hl: current tile LUT address
map_load_tile_and_attribute_vertical:
    ; Calculate VRAM address (base on the first row)
    push de
    push bc
    push hl
    ; A holds the current row to be rendered
    ld a, [ram_general_use_variable_7]
    ld de, 32
    ld l, a
    ld h, $00
    ; multiply A by the row width (in VRAM = 32)
    call mul_DE_HL_BCDEu
    pop hl
    ; result in DE is the fits element in the target row. Add it to ram_general_use_variable_9 (counter in the inner loop)
    ld a, [map_current_x]
    ld c, a
    ld a, [ram_general_use_variable_9]
    add c
    cp 32
    jr c, .no_correction
        sub a, 32
.no_correction
    add e
    ld e, a
    ld a, d
    adc $00
    ld d, a

    ld bc, _SCRN0
    ld a, e
    add c
    ld e, a
    ld a, d
    adc b
    ld d, a
    ; from this point onwards DE holds an address in VRAM (base _SCRN0)
    ; prepare to write to VRAM
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 0
    ld [rVBK], a
    ld a, [hl]
    ; add tile offset to hl
    ld c, a
    ld a, [ram_general_use_variable_4]
    add c
    call bgc_wait_for_VRAM
    ld [de], a

    ; load palette address
    ; add the number of tiles to hl to get the attribute tile
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 1
    ld [rVBK], a

    ; add offset to hl
    push hl
    ld a, [ram_general_use_variable_10]
    add a, l
    ld l, a
    ld a, [ram_general_use_variable_11]
    adc a, h
    ld h, a
    ld a, [hl]
    pop hl
    
    call bgc_wait_for_VRAM
    ld [de], a
    pop bc
    pop de
    
    ret

; Used an offset in DE to locate tiles and attribute in the room's LUT's and load into VRAM
; ram_general_use_variable_9: holds current row to be rendered
; de: Offset within the LUT
; hl: current tile LUT address
map_load_tile_and_attribute_horizontal:
    ; Calculate VRAM address (base on the first column)
    push de
    push bc
    push hl
    ; expression (Row *32 + column)
    ; A holds the current row to be rendered
    ld a, [ram_general_use_variable_9]
    ld e, a
    ; Add inital map Y and compensate for wrap around
    ld a, [map_current_y]
    add a, e
    cp 32
    jr c, .no_correction
        sub a, 32

.no_correction:
    ld de, 32
    ld l, a
    ld h, $00
    ; multiply A by the row width (in VRAM = 32)
    call mul_DE_HL_BCDEu
    pop hl
    ; result in DE is the fits element in the target row. Add it to ram_general_use_variable_9 (counter in the inner loop)
    ld a, [ram_general_use_variable_7]
    add e
    ld e, a
    ld a, d
    adc $00
    ld d, a

    ld bc, _SCRN0
    ld a, e
    add c
    ld e, a
    ld a, d
    adc b
    ld d, a
    ; from this point onwards DE holds an address in VRAM (base _SCRN0)
    ; prepare to write to VRAM
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 0
    ld [rVBK], a
    ld a, [hl]
    ; add tile offset to hl
    ld c, a
    ld a, [ram_general_use_variable_4]
    add c
    call bgc_wait_for_VRAM
    ld [de], a

    ; load palette address
    ; add the number of tiles to hl to get the attribute tile
    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 1
    ld [rVBK], a
    
    ; add offset to hl
    push hl
    ld a, [ram_general_use_variable_10]
    add a, l
    ld l, a
    ld a, [ram_general_use_variable_11]
    adc a, h
    ld h, a
    ld a, [hl]
    pop hl
    
    call bgc_wait_for_VRAM
    ld [de], a
    pop bc
    pop de
    ret 

; checks in [ram_general_use_variable_7] whether wrap around happened and corrects it
; return: the variable (ram_general_use_variable_7) is adjusted automatically
map_wrap_around_detector:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .is_next_row_is_below
        push hl
        ld a, [ram_general_use_variable_7]
        ld l, a
        ld a, $FF
        cp l
        pop hl
        jr nz, .no_wrap_around
            ld a, 31
            ld [ram_general_use_variable_7], a
            ret
.is_next_row_is_below:
    push hl
    ld a, [ram_general_use_variable_7]
    ld l, a
    ld a, 31
    cp l
    pop hl
    jr nc, .no_wrap_around
        ld a, 0
        ld [ram_general_use_variable_7], a

.no_wrap_around
    ret

; checks in [ram_general_use_variable_7] whether wrap around happened and corrects it
; return: the variable (ram_general_use_variable_7) is adjusted automatically
map_wrap_around_detector_horizontal:
    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .is_next_column_is_right
        push hl
        ld a, [ram_general_use_variable_7]
        ld l, a
        ld a, $FF
        cp l
        pop hl
        jr nz, .no_wrap_around
            ld a, 31
            ld [ram_general_use_variable_7], a
            ret
.is_next_column_is_right:
    push hl
    ld a, [ram_general_use_variable_7]
    ld l, a
    ld a, 31
    cp l
    pop hl
    jr nc, .no_wrap_around
        ld a, 0
        ld [ram_general_use_variable_7], a

.no_wrap_around
    ret

; based on the map horizontal position, calculate the first LUT address
; hl: holds the initial address of the tile LUT
; return (hl): adjusted address based on the map load direction
map_calculate_first_address_in_LUT_horizontal:
    ; In all cases, the offset must be applied to HL    
    ; Load initial address based on initial X and initial Y position
    push hl
    push de

    ; Expression HL + ((initial_y * map_width) + initial_x)
    ld a, [ram_general_use_variable_16]
    ld e, a
    ld d, $00

    ld a, [map_current_width]
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; copy de to bc
    ld c, e
    ld b, d

    ; Add width
    ld a, [ram_general_use_variable_15]
    add c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    pop de
    pop hl

    ld a, c
    add l
    ld l, a
    ld a, b
    adc h
    ld h, a
    
    ; check animation direction
    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .is_movement_to_the_right
        ; Upwards
        ; the first tile in the LUT is the first column in the last row
        ; expression: HL + ((MAP WIDTH)  - 1)
        ; calculate map dimensions
        push de
        push hl
        ld a, map_screen_width
        ld e, a
        ld d, $00
        ; MAP WIDTH - 1
        dec de

        ld a, map_screen_height
        ld l, a
        ld h, $00

        push de
        ; only DE will be used
        call mul_DE_HL_BCDEu
        ld c, e
        ld b, d
        pop hl
        pop de

        ; DE holds the offset to the first tile in the LUT. To get the real address, add it to the recovered hl
        ld a, l
        add e
        ld l, a
        ld a, h
        adc d
        ld h, a
        pop de
        jr .end_condition

    ; Downwards
.is_movement_to_the_right:    
    ; nothing to do. First tile in LUT is always the first one
.end_condition:
    ret


; based on the map vertical position, calculate the first LUT address
; hl: holds the initial address of the tile LUT
; return (hl): adjusted address based on the map load direction
map_calculate_first_address_in_LUT_vertical:
    ; Add offset before start calculation of initial address
    ; Expression HL + ((initial_y * map_width) + initial_x)
    push hl
    push de

    ld a, [ram_general_use_variable_16]
    ld e, a
    ld d, $00

    ld a, [map_current_width]
    ld l, a
    ld h, $00

    ; only DE will be used
    call mul_DE_HL_BCDEu
    
    ; copy de to bc
    ld c, e
    ld b, d

    ; Add width
    ld a, [ram_general_use_variable_15]
    add c
    ld c, a
    ld a, b
    adc $00
    ld b, a

    pop de
    pop hl

    ld a, c
    add l
    ld l, a
    ld a, b
    adc h
    ld h, a

    ; check animation direction
    push hl
    ld l, map_load_origin
    call check_animation_direction
    pop hl
    cp a, $01
    jr nz, .check_the_directions
        ; Nothing to do
        jr .end_condition

.check_the_directions:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .is_movement_downwards
        ; Upwards
        ; the first tile in the LUT is the first column in the last row
        ; expression: HL + ((MAP WIDTH) * (MAP HEIGHT - 1))
        ; calculate map dimensions
        push de
        push hl
        ld a, map_screen_height
        ld e, a
        ld d, $00
        ; MAP HEIGHT - 1
        dec de

        ld a, [map_current_width]
        ld l, a
        ld h, $00

        ; only DE will be used
        call mul_DE_HL_BCDEu
        ld c, e
        ld b, d
        pop hl

        ; DE hodls the offset to the first tile in the LUT. To get the real address, add it to the recovered hl
        ld a, l
        add e
        ld l, a
        ld a, h
        adc d
        ld h, a
        pop de
        jr .end_condition

    ; Downwards
.is_movement_downwards:    
    ; nothing to do. First tile in LUT is always the first one
.end_condition:
    ret

; Determines first column, based on the direction
; return (a): first columnt to be rendered
map_calculate_first_column:

    ; Check animation direction
    ld l, map_load_left
    call check_animation_direction
    jr nz, .is_movement_right
        ; if movement is to the left, the next column will be the one right before the first column of the currently loaded map.
        ; Watch for wrap around (if current column is 0, it must return to the last column.)
        ld a, [map_current_x]
        dec a
        cp $FF
        jr nz, .no_wrap_around_to_31
            ld a, 31
.no_wrap_around_to_31:
        jr .end_condition

.is_movement_right:
    ; If the movement is to the right, the next column will be the one right after the last column of the currently loaded map
    ; expression (MAP X + MAP WIDTH) + 1. Watch for wrap around (if result == 32, the next column is 0)
    ld a, map_screen_width
    ld l, a
    ld a, [map_current_x]
    add l
    ld l, a
    ld a, 31
    cp l
    jr nc, .no_wrap_around_to_0
        ld a, l
        ld l, 32
        sub l
        jr .end_condition
.no_wrap_around_to_0:
            ld a, l
    
.end_condition:
    ret

; Determines first row, based on the direction
; return (a): first row to be rendered
map_calculate_first_tile_row:

    ; check animation direction
    ld l, map_load_origin
    call check_animation_direction
    cp a, $01
    jr nz, .check_the_directions
        ld a, $00
        jr .end_condition

.check_the_directions:
    ld l, map_load_above
    call check_animation_direction
    jr nz, .is_movement_downwards
        ; Upwards
        ; From bottom to top, the first row will alwaus be the first one right above the current map position
        ; if it is equal to $FF (-1) wrap around to 31
        ld a, [map_current_y]
        dec a
        cp $FF
        jr nz, .no_wrap_around_to_31
            ld a, 31
.no_wrap_around_to_31:
        jr .end_condition

    ; Downwards
.is_movement_downwards:
    ; From top to bottom, the first row will always be the same as the one requested to be the first of the room
    ; The first row will always be the row right after the last row of the currently loaded map
    ; first_row = (MAP Y + MAP HEIGHT) -> if >= 32 then wrap around to 0 + 32 - (MAP Y + MAP HEIGHT)
    ld a, map_screen_height
    ld l, a
    ld a, [map_current_y]
    add l
    ld l, a
    ld a, 31
    cp l
    jr nc, .no_wrap_around_to_0
        ld a, l
        ld l, 32
        sub l
        jr .end_condition
.no_wrap_around_to_0:
            ld a, l
    
.end_condition:
    ret

; Scroll maps (one tile) vertically, in the direction held by a
; a: scrolling direction: 0 -> downwards 1 -> upwards
map_scroll_bg_vertically_with_animation:
    ld c, 4
    ld b, a
.one_more:
    call display_wait_vblank
    ld hl, rSCY
    ld a, b
    cp $00
    jr nz, .scroll_up

    push hl
    push de
    call map_move_player_character_vertically
    pop de
    pop hl

    ld a, [hl]
    add a, 2
    jr .scroll_complete

.scroll_up:

    push hl
    push de
    call map_move_player_character_vertically
    pop de
    pop hl

    ld a, [hl]
    add a, -2
.scroll_complete:
    ld [rSCY], a
    dec c
    ld a, c
    cp $00
    jr nz, .one_more
    ret

; Adjust character horizontal position as the screen moves
map_move_player_character_horizontally:
    push hl
    ld l, map_load_left
    call check_animation_direction
    pop hl
    jr nz, .right_values
        ld e, 2
        ld d, -1
        jr .animate

.right_values:
    ld e, -2
    ld d, 1

.animate:
    ld a, [ram_general_use_variable_8]
    sub a, 17
    jr c, .single_increment
    ld a, c
    cp $04
    jr z, .double_increment
.single_increment:
    ld a, c
    ld hl, _OAMRAM + 1
    ld a, [hl]
    add a, e
    ld [hl], a
    ld hl, _OAMRAM + 5
    ld a, [hl]
    add a, e
    ld [hl], a
    jr .complete
.double_increment:
    ld hl, _OAMRAM + 1
    ld a, [hl]
    add a, d
    ld [hl], a
    ld hl, _OAMRAM + 5
    ld a, [hl]
    add a, d
    ld [hl], a
.complete:
    ret

; Adjust character vertical position as the screen moves
map_move_player_character_vertically:
    push hl
    ld l, map_load_above
    call check_animation_direction
    pop hl
    jr nz, .down_values
        ld e, 2
        ld d, -0
        jr .animate

.down_values:
    ld e, -2
    ld d, 2

.animate:
    ld a, [ram_general_use_variable_8]
    sub a, 15
    jr c, .single_increment
    ld a, c
    cp $04
    jr z, .double_increment
.single_increment:
    ld a, c
    ld hl, _OAMRAM
    ld a, [hl]
    add a, e
    ld [hl], a
    ld hl, _OAMRAM + 4
    ld a, [hl]
    add a, e
    ld [hl], a
    jr .complete
.double_increment:
    ld hl, _OAMRAM
    ld a, [hl]
    add a, d
    ld [hl], a
    ld hl, _OAMRAM + 4
    ld a, [hl]
    add a, d
    ld [hl], a
.complete:
    ret

; Scroll maps (one tile) horizontal, in the direction held by a
; a: scrolling direction: 0 -> right 1 -> left
map_scroll_bg_horizontally_with_animation:
    ld c, 4
    ld b, a
.one_more:
    call display_wait_vblank
    ld hl, rSCX
    ld a, b
    cp $00
    jr nz, .scroll_right

    push hl
    push de
    call map_move_player_character_horizontally
    pop de
    pop hl
    
    ld a, [hl]
    add a, 2
    jr .scroll_complete

.scroll_right:

    push hl
    push de
    call map_move_player_character_horizontally
    pop de
    pop hl

    ld a, [hl]
    add a, -2

.scroll_complete:
    ld [rSCX], a
    dec c
    ld a, c
    cp $00
    jr nz, .one_more
    ret

; Set background scrolling position to map_current_y * 8
map_scroll_bg_to_target_position_without_animation:
    ld a, [map_current_y]
    sla a
    sla a
    sla a
    ld [rSCY], a
    ret

; checks whether current scroll direction is the one matching in l
; This function assumes the settings are loaded in ram_general_use_variable_1
; l: scroll direction
; return (a): 1 true, 0 false
check_animation_direction:
    ld a, [ram_general_use_variable_1]
    ; get the animation bits (for l and a)
    srl a
    srl a
    
    srl l
    srl l

    and $07
    cp l
    jr nz, .does_not_match
    ld a, $01
    ret
.does_not_match:
    ld a, $00
    ret

; Converts value from pixels to tiles
; a: target value
; return (a): picel value converted to tiles
map_convert_pixels_to_tiles;
    srl a
    srl a
    srl a
    ret

; Scroll Map Horizontally. The player position used is the raw value in OAMRAM
; a: scroll direction (1, left; 0 right)
map_scroll_map_horizontally_if_needed:
    cp $00
    jr nz, .scroll_right

        push hl
        ld a, [_OAMRAM + 1]
        inc a
        ld l, a
        ld a, $50
        cp l
        pop hl
        jr nc, .finish

        ; Check offset position (do not scroll if Offset + Screen Height == map Height)
        push hl
        ld a, [map_current_x_offset]
        add map_screen_width*8
        ld l, a
        ld a, [map_current_width]
        sla a
        sla a
        sla a
        cp l
        pop hl
        jr z, .finish
            ld a, [rSCX]
            inc a
            ld [rSCX], a

            ld a, [map_current_x_offset]
            inc a
            ld [map_current_x_offset], a
                
.skip_left_increment:
            ld a, [character_0_offset_x]
            sub a, 1
            ld [character_0_offset_x], a
            ret

.scroll_right:
    push hl
    ld a, [_OAMRAM + 1]
    inc a
    ld l, a
    ld a, $51
    cp l
    pop hl
    jr c, .finish


    ; Check offset position (do not scroll if 0)
    ld a, [map_current_x_offset]
    cp $00
    jr z, .finish
        ld a, [rSCX]
        dec a
        ld [rSCX], a

        ld a, [map_current_x_offset]
        dec a
        ld [map_current_x_offset], a

.skip_right_increment:
            ld a, [character_0_offset_x]
            add a, 1
            ld [character_0_offset_x], a

.finish
    ret


; Scroll Map Vertically
; a: scroll direction (1, up ; 0 down)
map_scroll_map_vertically_if_needed:
    cp $00
    jr nz, .scroll_down

    push hl
    ld a, [_OAMRAM]
    inc a
    ld l, a
    ld a, $58
    cp l
    pop hl
    jr nc, .finish

    ; Check offset position (do not scroll if Offset + Screen Height == map Height)
    push hl
    ld a, [map_current_y_offset]
    add map_screen_height*8
    ld l, a
    ld a, [map_current_height]
    sla a
    sla a
    sla a
    cp l
    pop hl
    jr z, .finish
            ld a, [rSCY]
            inc a
            ld [rSCY], a

            ld a, [map_current_y_offset]
            inc a
            ld [map_current_y_offset], a
.skip_up_increment:
            ld a, [character_0_offset_y]
            sub a, 1
            ld [character_0_offset_y], a
            ret

.scroll_down:
    push hl
    ld a, [_OAMRAM]
    inc a
    ld l, a
    ld a, $59
    cp l
    pop hl
    jr c, .finish

    ; Check offset position (do not scroll if 0)
    ld a, [map_current_y_offset]
    cp $00
    jr z, .finish
        ld a, [rSCY]
        dec a
        ld [rSCY], a

        ld a, [map_current_y_offset]
        dec a
        ld [map_current_y_offset], a
.skip_down_increment:
        ld a, [character_0_offset_y]
        add a, 1
        ld [character_0_offset_y], a

.finish:
    ret

; Convert map position in pixels into map tiles
; a: position in pixels
; return: position in tiles
map_pixel_to_tile:
    srl a
    srl a
    srl a
    ret

map_load_next_horizontal_row:
    ; check whether scrolling must happen
    push hl
    ld a, [_OAMRAM]
    inc a
    ld l, a
    ld a, $50
    cp l
    pop hl
    ret nc

    ; check whether the map needs to scroll
    ld a, [map_current_height]
    cp map_screen_height
    ret z

    ; check whether Y position is the beginning of a new tile.
    ld a, [character_0_y]
    and $07
    cp $00
    ret nz

    push bc
    ; calculate target row to load
    ld a, [map_current_y_offset]
    call map_pixel_to_tile
    ld b, a

    ; prepare variables
    ld a, [map_current_y]
    call map_pixel_to_tile
    add b
    ld b, a

    ; calculate target row to load
    ld a, [map_current_x_offset]
    call map_pixel_to_tile
    ld c, a

    ; prepare variables
    ld a, [map_current_x]
    call map_pixel_to_tile
    add c
    ld c, a

    ; Use with map_load_map_logic
    ; arguments: ram_general_use_variable_5/6: LUT initial address
    ;            ram_general_use_variable15/16: intiial X/Y

    ; load intiial LUT address
    ld a, [map_current_LUT_address_byte_1]
    ld [ram_general_use_variable_5], a
    ld a, [map_current_LUT_address_byte_2]
    ld [ram_general_use_variable_6], a

    ld a, c
    ld [ram_general_use_variable_15], a
    ld a, b
    ld [ram_general_use_variable_16], a

    ; load new logic layer
    call map_load_logic_layer

    pop bc
    ret
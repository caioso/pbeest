; Project Beest
; Map Controller
; Developed by Caio Souza Oliveira
; 19 Aug 2019

; ROOM Attributes
; inform that a new batch of palettes will be loaded VRAM 
map_load_palettes equ $01
; inform that a new batch of tiles will be loaded VRAM 
map_load_tiles equ $02

; in Map transition animation
map_load_no_transition equ $00
map_load_left_to_right_transition equ $04
map_load_right_to_left_transition equ $08
map_load_top_to_bottom_transition equ $0C
map_load_bottom_to_top_transition equ $10

; base tile memory base section address
map_tile_base_section_8000 equ 0
map_tile_base_section_9000 equ $20

; Loads Room data (tiles, palletes and logic) at a specific position in the video buffer (video buffer size 32x32). With or without animations.
; hl: Room initial address
; a: animation & Data Loading Bit Map
;    bit 0: load palettes
;    bit 1: load tiles
;    bit [2:5]
;      0x00: No Animation
;      0x01: Left-to-Right
;      0x02: Right-to-Left
;      0x03: top-to-bottom
;      0x04: bottom-to-top
;    bit 6: base tile bank
; bc: initial tile address (full 16 bits tile address)
; de: map initial position X(d) and Y(e) [in tiles, not pixels]
map_load_room:
    ; save temp variables 
    ; save map data loading attributes bit map
    push hl
    ld hl, ram_general_use_variable_1
    ld [hl], a
    ld hl, ram_general_use_variable_2
    ld [hl], c
    ld hl, ram_general_use_variable_3
    ld [hl], b
    pop hl

    ; Load room metadata
    ; load map position X(d), Y(e)
    push hl
    ld hl, map_current_x
    ld [hl], d
    ld hl, map_current_y
    ld [hl], e

    ; calculate tile map offset (based on initial address in VRAM)
    ; This is added to the room's tile LUT to find the correct tile ID for each entry in the room
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    bit 5, a
    jr z, .base_8000
        ld hl, $9000
        jr .continue_offset_tile_id_calculation
.base_8000:
        ld hl, $8000
.continue_offset_tile_id_calculation:
        ld a, c
        sub l
        ld e, a
        ld a, b
        sbc h
        ld d, a
        
        ;divide by 16 to get the correct tile offset (DE/BC)
        ld c, $10
        ld b, $00
        call div_DE_BC_DEBCu
        ; only the first byte of the division results matter (e)
        ld hl, ram_general_use_variable_4
        ld [hl], e

    pop hl

    ; hl holds the address of the room width byte
    ld de, map_current_width
    ld a, [hl]
    ld [de], a

    ; hl + 1 holds the address of the room height byte
    inc hl 
    ld de, map_current_height
    ld a, [hl]
    ld [de], a

    ; load palette target bank (nothing to do for now)
    inc hl
    
    ; Palette loading routine
    ; step 1: check whether the palettes are meant to be loaded
    inc hl
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_palettes
    jr z, .skip_palette_load
        ; step 2: load tiles
        ; load initial palette address
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load total palettes
        inc hl
        ld a, [hl]
        
        ; room palettes (0-6) always start at 0
        ld bc, $00

        ; move de to hl (required as function argument)
        push hl
        ld l, e
        ld h, d

        ; move a to de
        ld e, a
        ld d, $00

        ; load palettes
        call bgc_load_background_palette
        pop hl
        jr .palette_loaded_skipped

.skip_palette_load:
    inc hl
    inc hl
.palette_loaded_skipped:
    ; load background tiles (not actual LUT but tile-patterns in VRAM)
    ; load palette target bank (nothing to do for now)
    inc hl

    ; Tile loading routine
    ; Check whether tiles should be loaded into VRAM and at which initial offset
    push hl
    ld hl, ram_general_use_variable_1
    ld a, [hl]
    pop hl
    and map_load_tiles
    jr z, .skip_tiles_load
        ; load background tiles initial address
        inc hl
        ld a, [hl]
        ld e, a
        inc hl
        ld a, [hl]
        ld d, a

        ; load number of tiles
        inc hl
        ld a, [hl]
        ld c, a
        inc hl
        ld a, [hl]
        ld b, a

        ; move de to hl
        push hl
        ld l, e
        ld h, d
        
        ; configure rVBK to load tiles (a = 0)
        ld a, $00

        ; load initial tiles address
        push hl
        ld hl, ram_general_use_variable_2
        ld e, [hl]
        ld hl, ram_general_use_variable_3
        ld d, [hl]
        pop hl
        ; load tile initial address in 
        call tilecrt_load_tiles

        pop hl
        jr .tile_loaded_skipped

.skip_tiles_load:
    inc hl
    inc hl
    inc hl
    inc hl
.tile_loaded_skipped:
    ; Restore room animation attributes

    ; step 3: load LUTS and map logic
    ; calculate number of entries per LUT (width*height)
    push hl
    ld hl, map_current_width
    ld l, [hl]
    ld h, $00
    ld de, map_current_height
    ld a, [de]
    ld e, a
    ld d, $00
    ; result in BCDE
    call mul_DE_HL_BCDEu

    ; save results (since the max room dimension is 32x32, save only DE)
    ld hl, ram_general_use_variable_2
    ld [hl], e
    ld hl, ram_general_use_variable_3
    ld [hl], d

    pop hl
    ; load room's tile LUT
    inc hl

    ;; v BOTTOM TO TOP CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ; move hl to the end of the last row
    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a

    ld a, [map_current_width]
    ld e, a
    ld a, l
    sub e
    ld l, a
    ld a, h
    sbc $00
    ld h, a
    ;; ^ BOTTOM TO TOP CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ; Calculate initial tile address (relative to _SCRN1)
    ; Expression (Y*MapWidth + X) + &_SCRN1
    ;push hl
    ;ld de, map_current_y
    ;ld a, [de]
    ;ld l, a
    ;ld h, $00

    ;ld a, map_max_width
    ;ld e, a
    ;ld d, $00
    
    ; result in BCDE
    ;call mul_DE_HL_BCDEu

    ; Only DE will be needed
    ; add map X
    ;ld hl, map_current_x
    ;ld a, [hl]
    ;ld l, a
    ;ld h, $00

    ; add DE to HL (store in DE)
    ;ld a, e
    ;add l
    ;ld e, a
    ;ld a, d
    ;adc h
    ;ld d, a

    ; add Base address of _SCRN0
    ; DE will hold the address in the video memory to receive the LUT data
    ;ld hl, _SCRN0
    ;ld a, e
    ;add l
    ;ld e, a
    ;ld a, d
    ;adc h
    ;ld d, a

    ; load counters
    ;ld hl, map_current_height
    ;ld a, [hl]
    ;ld c, a

   ; initialize Y boundaries counter
    ;ld hl, map_current_y
    ;ld a, [hl]
    ;ld hl, ram_general_use_variable_6
    ;ld [hl], a

    ;pop hl
    ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ; Calculate initial tile address (relative to _SCRN0)
    ; Expression ((Y + (MapHeight - 1))*MapWidth + X) + &_SCRN0
    push hl
    ld a, [map_current_y]
    ld l, a
    ld h, $00

    ld a, [map_current_height]
    ld e, a
    ld d, $00
    dec de

    ld a, l
    add e
    ld l, a
    ld a, h
    adc d
    ld h, a

    ld a, 31
    cp l
    jr nc, .no_correction
        ld a, l
        sub a, 32
        ld l, a 

.no_correction:
    ld a, map_max_width
    ld e, a
    ld d, $00
    
    ; result in BCDE
    call mul_DE_HL_BCDEu

    ; Only DE will be needed
    ; add map X
    ld hl, map_current_x
    ld a, [hl]
    ld l, a
    ld h, $00

    ; add DE to HL (store in DE)
    ld a, e
    add l
    ld e, a
    ld a, d
    adc h
    ld d, a

    ; add Base address of _SCRN0
    ; DE will hold the address in the video memory to receive the LUT data
    ld hl, _SCRN0
    ld a, e
    add l
    ld e, a
    ld a, d
    adc h
    ld d, a

    ; load counters
    ld hl, map_current_height
    ld a, [hl]
    ld c, a

   ; initialize Y boundaries counter
    push bc
    ld hl, map_current_y
    ld a, [hl]
    ld c, a
    ld hl, map_current_height
    ld a, [hl]
    add a, c
    dec a

    ld hl, ram_general_use_variable_6
    ld [hl], a
    pop bc
    pop hl

; **horizontal** loading
.outer_loop:
    ; reload map width coutner
    push hl
    ld hl, map_current_width
    ld a, [hl]
    ld b, a

    ; initialize X boundaries counter
    ld hl, map_current_x
    ld a, [hl]
    ld hl, ram_general_use_variable_5
    ld [hl], a

    pop hl

.inner_loop:

    ; Load tiles LUT
    ; set rVBK to 0 (tiles bank)
    ld a, 0
    ld [rVBK], a

    ld a, [hl]

    ; add offset to tiles
    push hl
    ld hl, ram_general_use_variable_4
    ld l, [hl]
    add a, l
    pop hl

    ; Wait until CPU has granted access to VRAM
    push hl
    ld   hl, rSTAT
.wait_for_vram:           
    bit  $01, [hl]
    jr   nz, .wait_for_vram 
    pop hl

    ld [de], a
    
    ; load attributes LUT
    ; set rVBK to 1 (atributes bank)
    ld a, 1
    ld [rVBK], a
    push bc
    push hl
    ld hl, ram_general_use_variable_2
    ld c, [hl]
    ld hl, ram_general_use_variable_3
    ld b, [hl]
    pop hl

    ; calculate attribute LUT address based on the current address of DE + the size of the room
    push hl
    ld a, c
    add l
    ld l, a
    ld a, b
    adc h
    ld h, a

    ; Wait until CPU has granted access to VRAM
    push hl
    ld   hl, rSTAT
.wait_for_vram_again:           
    bit  $01, [hl]
    jr   nz, .wait_for_vram_again 
    pop hl

    ; load attribute byte into VRAM
    ld a, [hl]
    ld [de], a

    pop hl
    pop bc

    ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;inc hl
    ;inc de
    ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    inc hl
    inc de

    dec b
    ld a, b
    cp $00
    ; if b is not 0, there are still bytes to be loaded in the current line
    jr z, .inner_loop_complete

        ; check boundaries
        push hl
        ld hl, ram_general_use_variable_5
        ld a, [hl]
        inc a
        cp a, map_max_width
        jr nz, .save_x_counter
            ; warp around (X starts at 0 now)
            ld [hl], $00
            ; return de to the beginning of the row
            ld a, e
            sub $20
            ld e, a
            ld a, d
            sbc $00
            ld d, a
            pop hl
            jr .inner_loop
.save_x_counter:
        ld [hl], a
        pop hl
    jr .inner_loop

.inner_loop_complete:
    ;; v BOTTOM TO TOP CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ; Adjust HL to point to the previous row
    ld a, [map_current_width]
    sla a
    ld e, a
    ld a, l
    sub e
    ld l, a
    ld a, h
    sbc $00
    ld h, a
    ;; ^ BOTTOM TO TOP CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ; one iteration of the outer loop is completed
    dec c
    ld a, c
    cp $00

    ; not done yet, back to the beginning of the outer loop
    jr z, .tile_lut_load_complete
    ; check boundaries
    push hl
    ld hl, ram_general_use_variable_6
    ld a, [hl]

    ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;inc a
    ;cp a, map_max_height
    ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    dec a
    cp a, $FF
    jr nz, .save_y_counter
        ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ; warp around (Y starts at 0 now)
        ; ld a, $00
        ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       
        ; warp around (Y starts at the last row now)
        ld a, map_max_height - 1

.save_y_counter:
        ld [hl], a
        pop hl

        ; Push DE to the next row, starting at the required X
        push hl
        push bc
        
        ; calculate current row
        ld de, ram_general_use_variable_6
        ld a, [de]
        ld l, a
        ld h, $00

        ld a, 31
        cp l
        jr nc, .no_correction_required
            ld a, l
            sub a, 32
            ld l, a 
        ;; ^ BOTTOM TO TOP CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

.no_correction_required:
        ld a, map_max_width
        ld e, a
        ld d, $00
        ; result in BCDE
        call mul_DE_HL_BCDEu

        ; Only DE will be needed
        ; add map X
        ld hl, map_current_x
        ld a, [hl]
        ld l, a
        ld h, $00

        ; add DE to HL (store in DE)
        ld a, e
        add l
        ld e, a
        ld a, d
        adc h
        ld d, a

        ; add Base address of _SCRN0
        ; DE will hold the address in the video memory to receive the LUT data
        ld hl, _SCRN0
        ld a, e
        add l
        ld e, a
        ld a, d
        adc h
        ld d, a

        pop bc
        pop hl

        ; Scroll map
        push hl
        ld hl, ram_general_use_variable_1
        ld a, [hl]
        pop hl
        and $1C ; (no animations)
        jr z, .skip_animation
            push hl
            push bc

            ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ; scroll downwards
            ;ld a, $00
            ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ; scroll upwards
            ld a, $01
            call map_scroll_bg_vertically_with_animation
            
            pop bc
            pop hl
        
.skip_animation:
        jp .outer_loop

.tile_lut_load_complete:
        push hl
        ld hl, ram_general_use_variable_1
        ld a, [hl]
        pop hl
        and $1C ; (no animations)
        jr z, .complete_map_loading
            ;; v TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ; scroll downwards
            ;ld a, $00
            ;; ^ TOP BOTTOM CASE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ; scroll upwards
            ld a, $01
            call map_scroll_bg_vertically_with_animation
            jr .skip_position_adjustment

.complete_map_loading:
 ld hl, ram_general_use_variable_1
    ld a, [hl]
    and $1C ; (no animations)
    jr nz, .skip_position_adjustment
        call map_scroll_bg_to_target_position_without_animation
        
.skip_position_adjustment:
    ret

; Scroll maps (one tile) vertically, in the direction held by a
; a: scrolling direction: 0 -> downwards 1 -> upwards
map_scroll_bg_vertically_with_animation:
    ld c, 8
    ld b, a
.one_more:
    call display_wait_vblank
    ld hl, rSCY
    ld a, b
    cp $00
    jr nz, .scroll_up
    ld a, [hl]
    add a, 1
    jr .scroll_complete
.scroll_up:
    ld a, [hl]
    add a, -1
.scroll_complete:
    ld [rSCY], a
    dec c
    ld a, c
    cp $00
    jr nz, .one_more
    ret

; Set background scrolling position to map_current_y * 8
map_scroll_bg_to_target_position_without_animation:
    ld a, [map_current_y]
    sla a
    sla a
    sla a
    ld [rSCY], a
    ret